{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the <code>libeq</code> library for the solution of thermodynamic equilibrium. It is the core routine of PyES, a frontend for the calculation of species distribution and simulation of titration curves.</p> <ol> <li>Tutorials</li> <li>Reference</li> <li>Explanation</li> </ol>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This library is based on the work of many research group on the topic, in particular the works of Prof. Sammartano's research group from the University of Messina and the Prof. Carrayrou from the University of Strasbourg.</p> <p>The code has been heavly inspired by the works of Prof. Blasco from the University of Valencia.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>libeq<ul> <li>data_structure</li> <li>errors</li> <li>excepts</li> <li>optimizers<ul> <li>fitter</li> <li>potentiometry</li> </ul> </li> <li>outer_fixed_point<ul> <li>wrappers</li> </ul> </li> <li>parsers<ul> <li>bstac</li> </ul> </li> <li>solver<ul> <li>damping</li> <li>nr</li> <li>solids_solver</li> <li>solver</li> <li>solver_utils</li> </ul> </li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/libeq/","title":"libeq","text":""},{"location":"reference/libeq/#libeq.SolverData","title":"SolverData","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>src/libeq/data_structure.py</code> <pre><code>class SolverData(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    distribution_opts: DistributionParameters = DistributionParameters()\n    titration_opts: SimulationTitrationParameters = SimulationTitrationParameters()\n    potentiometry_options: PotentiometryOptions = PotentiometryOptions()\n\n    components: List[str]\n    stoichiometry: Np2DArrayInt8\n    solid_stoichiometry: Np2DArrayInt8\n    log_beta: Np1DArrayFp64\n    log_beta_sigma: Np1DArrayFp64 = np.array([])\n    log_beta_ref_dbh: Np2DArrayFp64 = np.empty((0, 2))\n    log_ks: Np1DArrayFp64 = np.array([])\n    log_ks_sigma: Np1DArrayFp64 = np.array([])\n    log_ks_ref_dbh: Np2DArrayFp64 = np.empty((0, 2))\n\n    charges: Np1DArrayFp64 = np.array([])\n\n    ionic_strength_dependence: bool = False\n    reference_ionic_str_species: Np1DArrayFp64 | float = 0\n    reference_ionic_str_solids: Np1DArrayFp64 | float = 0\n    dbh_params: Np1DArrayFp64 = np.zeros(8)\n\n    @computed_field\n    @cached_property\n    def species_charges(self) -&gt; Np1DArrayFp64:\n        return (self.stoichiometry * self.charges[:, np.newaxis]).sum(axis=0)\n\n    @computed_field\n    @cached_property\n    def solid_charges(self) -&gt; Np1DArrayFp64:\n        return (self.solid_stoichiometry * self.charges[:, np.newaxis]).sum(axis=0)\n\n    @computed_field(repr=False)\n    @cached_property\n    def z_star_species(self) -&gt; Np1DArrayFp64:\n        return (self.stoichiometry * (self.charges[:, np.newaxis] ** 2)).sum(\n            axis=0\n        ) - self.species_charges**2\n\n    @computed_field(repr=False)\n    @cached_property\n    def p_star_species(self) -&gt; Np1DArrayFp64:\n        return self.stoichiometry.sum(axis=0) - 1\n\n    @computed_field(repr=False)\n    @cached_property\n    def z_star_solids(self) -&gt; Np1DArrayFp64:\n        return (self.solid_stoichiometry * (self.charges[:, np.newaxis] ** 2)).sum(\n            axis=0\n        ) - self.solid_charges**2\n\n    @computed_field(repr=False)\n    @cached_property\n    def p_star_solids(self) -&gt; Np1DArrayFp64:\n        return self.solid_stoichiometry.sum(axis=0)\n\n    @computed_field\n    @cached_property\n    def dbh_values(self) -&gt; Dict[str, Np1DArrayFp64]:\n        result = dict()\n        for phase, iref, per_species_cde, z, p in zip(\n            (\"species\", \"solids\"),\n            (self.reference_ionic_str_species, self.reference_ionic_str_solids),\n            (self.log_beta_ref_dbh, self.log_ks_ref_dbh),\n            (self.z_star_species, self.z_star_solids),\n            (self.p_star_species, self.p_star_solids),\n        ):\n            dbh_values = dict()\n            dbh_values[\"azast\"] = self.dbh_params[0] * z\n            dbh_values[\"adh\"] = self.dbh_params[0]\n            dbh_values[\"bdh\"] = self.dbh_params[1]\n            dbh_values[\"cdh\"] = self.dbh_params[2] * p + self.dbh_params[3] * z\n            dbh_values[\"ddh\"] = self.dbh_params[4] * p + self.dbh_params[5] * z\n            dbh_values[\"edh\"] = self.dbh_params[6] * p + self.dbh_params[7] * z\n            dbh_values[\"fib\"] = np.sqrt(iref) / (1 + self.dbh_params[1] * np.sqrt(iref))\n\n            not_zero_columns = np.where(np.any(per_species_cde != 0, axis=0))[0]\n            for i in not_zero_columns:\n                dbh_values[\"cdh\"][i] = per_species_cde[0][i]\n                dbh_values[\"ddh\"][i] = per_species_cde[1][i]\n                dbh_values[\"edh\"][i] = per_species_cde[2][i]\n\n            result[phase] = dbh_values\n        return result\n\n    @computed_field\n    @cached_property\n    def species_names(self) -&gt; List[str]:\n        return self.components + _assemble_species_names(\n            self.components, self.stoichiometry\n        )\n\n    @computed_field\n    @cached_property\n    def solids_names(self) -&gt; List[str]:\n        return _assemble_species_names(self.components, self.solid_stoichiometry)\n\n    @computed_field\n    @cached_property\n    def nc(self) -&gt; int:\n        return self.stoichiometry.shape[0]\n\n    @computed_field\n    @cached_property\n    def ns(self) -&gt; int:\n        return self.stoichiometry.shape[1]\n\n    @computed_field\n    @cached_property\n    def nf(self) -&gt; int:\n        return self.solid_stoichiometry.shape[1]\n\n    @classmethod\n    def load_from_bstac(cls, file_path: str) -&gt; \"SolverData\":\n        data = dict()\n        with open(file_path, \"r\") as file:\n            lines = file.readlines()\n        parsed_data = parse_BSTAC_file(lines)\n\n        temperature = parsed_data[\"TEMP\"]\n        data[\"stoichiometry\"] = np.array(\n            [\n                [d[key] for key in d if key.startswith(\"IX\")]\n                for d in parsed_data[\"species\"]\n            ]\n        ).T\n        data[\"solid_stoichiometry\"] = np.empty(\n            (data[\"stoichiometry\"].shape[0], 0), dtype=np.int8\n        )\n        data[\"log_beta\"] = np.array([d[\"BLOG\"] for d in parsed_data[\"species\"]])\n\n        data[\"charges\"] = np.array(parsed_data.get(\"charges\", []))\n        data[\"components\"] = parsed_data[\"comp_name\"]\n        data[\"ionic_strength_dependence\"] = parsed_data[\"ICD\"] != 0\n        if data[\"ionic_strength_dependence\"]:\n            data[\"reference_ionic_str_species\"] = np.array(\n                [parsed_data[\"IREF\"] for _ in range(data[\"stoichiometry\"].shape[1])]\n            )\n            data[\"reference_ionic_str_solids\"] = np.array(\n                [\n                    parsed_data[\"IREF\"]\n                    for _ in range(data[\"solid_stoichiometry\"].shape[1])\n                ]\n            )\n            data[\"dbh_params\"] = [\n                parsed_data[i] for i in [\"AT\", \"BT\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n            ]\n\n        titration_options = [\n            PotentiometryTitrationsParameters(\n                c0=np.array([c[\"C0\"] for c in t[\"components_concentrations\"]]),\n                ct=np.array([c[\"CTT\"] for c in t[\"components_concentrations\"]]),\n                electro_active_compoment=(\n                    t[\"titration_comp_settings\"][1]\n                    if t[\"titration_comp_settings\"][1] != 0\n                    else len(data[\"components\"]) - 1\n                ),\n                e0=t[\"potential_params\"][0],\n                e0_sigma=t[\"potential_params\"][1],\n                slope=(\n                    t[\"potential_params\"][4]\n                    if t[\"potential_params\"][4] != 0\n                    else (temperature + 273.15) / 11.6048 * 2.303\n                ),\n                v0=t[\"v_params\"][0],\n                v0_sigma=t[\"v_params\"][1],\n                v_add=np.array(t[\"volume\"]),\n                emf=np.array(t[\"potential\"]),\n            )\n            for t in parsed_data[\"titrations\"]\n        ]\n\n        weights = parsed_data.get(\"MODE\", 1)\n        match weights:\n            case 0:\n                weights = \"calculated\"\n            case 1:\n                weights = \"constants\"\n            case 2:\n                weights = \"given\"\n            case _:\n                raise ValueError(\"Invalid MODE value\")\n\n        data[\"potentiometry_options\"] = PotentiometryOptions(\n            titrations=titration_options,\n            weights=weights,\n            px_range=[parsed_data[\"PHI\"], parsed_data[\"PHF\"]],\n            beta_flags=[s[\"KEY\"] for s in parsed_data[\"species\"]],\n            conc_flags=[],\n            pot_flags=[],\n        )\n        return cls(**data)\n\n    @classmethod\n    def load_from_pyes(cls, pyes_data: str | dict) -&gt; \"SolverData\":\n        if isinstance(pyes_data, str):\n            with open(pyes_data, \"r\") as file:\n                pyes_data = json.load(file)\n        data = dict()\n        data[\"components\"] = list(pyes_data[\"compModel\"][\"Name\"].values())\n\n        data[\"stoichiometry\"] = np.row_stack(\n            [\n                list(pyes_data[\"speciesModel\"][col].values())\n                for col in data[\"components\"]\n            ]\n        )\n        data[\"log_beta\"] = np.array(list(pyes_data[\"speciesModel\"][\"LogB\"].values()))\n        data[\"log_beta_sigma\"] = np.array(\n            list(pyes_data[\"speciesModel\"][\"Sigma\"].values())\n        )\n        data[\"log_beta_ref_dbh\"] = np.vstack(\n            (\n                list(pyes_data[\"speciesModel\"][\"CGF\"].values()),\n                list(pyes_data[\"speciesModel\"][\"DGF\"].values()),\n                list(pyes_data[\"speciesModel\"][\"EGF\"].values()),\n            )\n        )\n\n        data[\"solid_stoichiometry\"] = np.row_stack(\n            [\n                list(pyes_data[\"solidSpeciesModel\"][col].values())\n                for col in data[\"components\"]\n            ]\n        )\n        data[\"log_ks\"] = np.array(\n            list(pyes_data[\"solidSpeciesModel\"][\"LogKs\"].values())\n        )\n        data[\"log_ks_sigma\"] = np.array(\n            list(pyes_data[\"solidSpeciesModel\"][\"Sigma\"].values())\n        )\n        data[\"log_ks_ref_dbh\"] = np.vstack(\n            (\n                list(pyes_data[\"solidSpeciesModel\"][\"CGF\"].values()),\n                list(pyes_data[\"solidSpeciesModel\"][\"DGF\"].values()),\n                list(pyes_data[\"solidSpeciesModel\"][\"EGF\"].values()),\n            )\n        )\n\n        data[\"charges\"] = np.array(list(pyes_data[\"compModel\"][\"Charge\"].values()))\n        data[\"ionic_strength_dependence\"] = pyes_data[\"imode\"] != 0\n        data[\"reference_ionic_str_species\"] = np.array(\n            list(pyes_data[\"speciesModel\"][\"Ref. Ionic Str.\"].values())\n        )\n        data[\"reference_ionic_str_species\"] = np.where(\n            data[\"reference_ionic_str_species\"] == 0,\n            pyes_data[\"ris\"],\n            data[\"reference_ionic_str_species\"],\n        )\n\n        data[\"reference_ionic_str_solids\"] = np.array(\n            list(pyes_data[\"solidSpeciesModel\"][\"Ref. Ionic Str.\"].values())\n        )\n        data[\"reference_ionic_str_solids\"] = np.where(\n            data[\"reference_ionic_str_solids\"] == 0,\n            pyes_data[\"ris\"],\n            data[\"reference_ionic_str_solids\"],\n        )\n\n        data[\"dbh_params\"] = [\n            pyes_data[name] for name in [\"a\", \"b\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n        ]\n\n        data[\"distribution_opts\"] = DistributionParameters(\n            c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n            c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n            initial_log=pyes_data.get(\"initialLog\"),\n            final_log=pyes_data.get(\"finalLog\"),\n            log_increments=pyes_data.get(\"logInc\"),\n            independent_component=pyes_data.get(\"ind_comp\"),\n        )\n\n        data[\"titration_opts\"] = SimulationTitrationParameters(\n            c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n            c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n            ct=np.array(list(pyes_data[\"concModel\"][\"CT\"].values())),\n            ct_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma CT\"].values())),\n            v0=pyes_data.get(\"v0\"),\n            v_increment=pyes_data.get(\"vinc\"),\n            n_add=pyes_data.get(\"nop\"),\n        )\n        return cls(**data)\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='forbid')\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.distribution_opts","title":"distribution_opts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distribution_opts: DistributionParameters = (\n    DistributionParameters()\n)\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.titration_opts","title":"titration_opts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>titration_opts: SimulationTitrationParameters = (\n    SimulationTitrationParameters()\n)\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.potentiometry_options","title":"potentiometry_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>potentiometry_options: PotentiometryOptions = (\n    PotentiometryOptions()\n)\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.components","title":"components  <code>instance-attribute</code>","text":"<pre><code>components: List[str]\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.stoichiometry","title":"stoichiometry  <code>instance-attribute</code>","text":"<pre><code>stoichiometry: Np2DArrayInt8\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.solid_stoichiometry","title":"solid_stoichiometry  <code>instance-attribute</code>","text":"<pre><code>solid_stoichiometry: Np2DArrayInt8\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.log_beta","title":"log_beta  <code>instance-attribute</code>","text":"<pre><code>log_beta: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.log_beta_sigma","title":"log_beta_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_beta_sigma: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.log_beta_ref_dbh","title":"log_beta_ref_dbh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_beta_ref_dbh: Np2DArrayFp64 = empty((0, 2))\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.log_ks","title":"log_ks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_ks: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.log_ks_sigma","title":"log_ks_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_ks_sigma: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.log_ks_ref_dbh","title":"log_ks_ref_dbh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_ks_ref_dbh: Np2DArrayFp64 = empty((0, 2))\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.charges","title":"charges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>charges: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.ionic_strength_dependence","title":"ionic_strength_dependence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ionic_strength_dependence: bool = False\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.reference_ionic_str_species","title":"reference_ionic_str_species  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_ionic_str_species: Np1DArrayFp64 | float = 0\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.reference_ionic_str_solids","title":"reference_ionic_str_solids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_ionic_str_solids: Np1DArrayFp64 | float = 0\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.dbh_params","title":"dbh_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dbh_params: Np1DArrayFp64 = zeros(8)\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.species_charges","title":"species_charges  <code>cached</code> <code>property</code>","text":"<pre><code>species_charges: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.solid_charges","title":"solid_charges  <code>cached</code> <code>property</code>","text":"<pre><code>solid_charges: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.z_star_species","title":"z_star_species  <code>cached</code> <code>property</code>","text":"<pre><code>z_star_species: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.p_star_species","title":"p_star_species  <code>cached</code> <code>property</code>","text":"<pre><code>p_star_species: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.z_star_solids","title":"z_star_solids  <code>cached</code> <code>property</code>","text":"<pre><code>z_star_solids: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.p_star_solids","title":"p_star_solids  <code>cached</code> <code>property</code>","text":"<pre><code>p_star_solids: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.dbh_values","title":"dbh_values  <code>cached</code> <code>property</code>","text":"<pre><code>dbh_values: Dict[str, Np1DArrayFp64]\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.species_names","title":"species_names  <code>cached</code> <code>property</code>","text":"<pre><code>species_names: List[str]\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.solids_names","title":"solids_names  <code>cached</code> <code>property</code>","text":"<pre><code>solids_names: List[str]\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.nc","title":"nc  <code>cached</code> <code>property</code>","text":"<pre><code>nc: int\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.ns","title":"ns  <code>cached</code> <code>property</code>","text":"<pre><code>ns: int\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.nf","title":"nf  <code>cached</code> <code>property</code>","text":"<pre><code>nf: int\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.load_from_bstac","title":"load_from_bstac  <code>classmethod</code>","text":"<pre><code>load_from_bstac(file_path: str) -&gt; SolverData\n</code></pre> Source code in <code>src/libeq/data_structure.py</code> <pre><code>@classmethod\ndef load_from_bstac(cls, file_path: str) -&gt; \"SolverData\":\n    data = dict()\n    with open(file_path, \"r\") as file:\n        lines = file.readlines()\n    parsed_data = parse_BSTAC_file(lines)\n\n    temperature = parsed_data[\"TEMP\"]\n    data[\"stoichiometry\"] = np.array(\n        [\n            [d[key] for key in d if key.startswith(\"IX\")]\n            for d in parsed_data[\"species\"]\n        ]\n    ).T\n    data[\"solid_stoichiometry\"] = np.empty(\n        (data[\"stoichiometry\"].shape[0], 0), dtype=np.int8\n    )\n    data[\"log_beta\"] = np.array([d[\"BLOG\"] for d in parsed_data[\"species\"]])\n\n    data[\"charges\"] = np.array(parsed_data.get(\"charges\", []))\n    data[\"components\"] = parsed_data[\"comp_name\"]\n    data[\"ionic_strength_dependence\"] = parsed_data[\"ICD\"] != 0\n    if data[\"ionic_strength_dependence\"]:\n        data[\"reference_ionic_str_species\"] = np.array(\n            [parsed_data[\"IREF\"] for _ in range(data[\"stoichiometry\"].shape[1])]\n        )\n        data[\"reference_ionic_str_solids\"] = np.array(\n            [\n                parsed_data[\"IREF\"]\n                for _ in range(data[\"solid_stoichiometry\"].shape[1])\n            ]\n        )\n        data[\"dbh_params\"] = [\n            parsed_data[i] for i in [\"AT\", \"BT\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n        ]\n\n    titration_options = [\n        PotentiometryTitrationsParameters(\n            c0=np.array([c[\"C0\"] for c in t[\"components_concentrations\"]]),\n            ct=np.array([c[\"CTT\"] for c in t[\"components_concentrations\"]]),\n            electro_active_compoment=(\n                t[\"titration_comp_settings\"][1]\n                if t[\"titration_comp_settings\"][1] != 0\n                else len(data[\"components\"]) - 1\n            ),\n            e0=t[\"potential_params\"][0],\n            e0_sigma=t[\"potential_params\"][1],\n            slope=(\n                t[\"potential_params\"][4]\n                if t[\"potential_params\"][4] != 0\n                else (temperature + 273.15) / 11.6048 * 2.303\n            ),\n            v0=t[\"v_params\"][0],\n            v0_sigma=t[\"v_params\"][1],\n            v_add=np.array(t[\"volume\"]),\n            emf=np.array(t[\"potential\"]),\n        )\n        for t in parsed_data[\"titrations\"]\n    ]\n\n    weights = parsed_data.get(\"MODE\", 1)\n    match weights:\n        case 0:\n            weights = \"calculated\"\n        case 1:\n            weights = \"constants\"\n        case 2:\n            weights = \"given\"\n        case _:\n            raise ValueError(\"Invalid MODE value\")\n\n    data[\"potentiometry_options\"] = PotentiometryOptions(\n        titrations=titration_options,\n        weights=weights,\n        px_range=[parsed_data[\"PHI\"], parsed_data[\"PHF\"]],\n        beta_flags=[s[\"KEY\"] for s in parsed_data[\"species\"]],\n        conc_flags=[],\n        pot_flags=[],\n    )\n    return cls(**data)\n</code></pre>"},{"location":"reference/libeq/#libeq.SolverData.load_from_pyes","title":"load_from_pyes  <code>classmethod</code>","text":"<pre><code>load_from_pyes(pyes_data: str | dict) -&gt; SolverData\n</code></pre> Source code in <code>src/libeq/data_structure.py</code> <pre><code>@classmethod\ndef load_from_pyes(cls, pyes_data: str | dict) -&gt; \"SolverData\":\n    if isinstance(pyes_data, str):\n        with open(pyes_data, \"r\") as file:\n            pyes_data = json.load(file)\n    data = dict()\n    data[\"components\"] = list(pyes_data[\"compModel\"][\"Name\"].values())\n\n    data[\"stoichiometry\"] = np.row_stack(\n        [\n            list(pyes_data[\"speciesModel\"][col].values())\n            for col in data[\"components\"]\n        ]\n    )\n    data[\"log_beta\"] = np.array(list(pyes_data[\"speciesModel\"][\"LogB\"].values()))\n    data[\"log_beta_sigma\"] = np.array(\n        list(pyes_data[\"speciesModel\"][\"Sigma\"].values())\n    )\n    data[\"log_beta_ref_dbh\"] = np.vstack(\n        (\n            list(pyes_data[\"speciesModel\"][\"CGF\"].values()),\n            list(pyes_data[\"speciesModel\"][\"DGF\"].values()),\n            list(pyes_data[\"speciesModel\"][\"EGF\"].values()),\n        )\n    )\n\n    data[\"solid_stoichiometry\"] = np.row_stack(\n        [\n            list(pyes_data[\"solidSpeciesModel\"][col].values())\n            for col in data[\"components\"]\n        ]\n    )\n    data[\"log_ks\"] = np.array(\n        list(pyes_data[\"solidSpeciesModel\"][\"LogKs\"].values())\n    )\n    data[\"log_ks_sigma\"] = np.array(\n        list(pyes_data[\"solidSpeciesModel\"][\"Sigma\"].values())\n    )\n    data[\"log_ks_ref_dbh\"] = np.vstack(\n        (\n            list(pyes_data[\"solidSpeciesModel\"][\"CGF\"].values()),\n            list(pyes_data[\"solidSpeciesModel\"][\"DGF\"].values()),\n            list(pyes_data[\"solidSpeciesModel\"][\"EGF\"].values()),\n        )\n    )\n\n    data[\"charges\"] = np.array(list(pyes_data[\"compModel\"][\"Charge\"].values()))\n    data[\"ionic_strength_dependence\"] = pyes_data[\"imode\"] != 0\n    data[\"reference_ionic_str_species\"] = np.array(\n        list(pyes_data[\"speciesModel\"][\"Ref. Ionic Str.\"].values())\n    )\n    data[\"reference_ionic_str_species\"] = np.where(\n        data[\"reference_ionic_str_species\"] == 0,\n        pyes_data[\"ris\"],\n        data[\"reference_ionic_str_species\"],\n    )\n\n    data[\"reference_ionic_str_solids\"] = np.array(\n        list(pyes_data[\"solidSpeciesModel\"][\"Ref. Ionic Str.\"].values())\n    )\n    data[\"reference_ionic_str_solids\"] = np.where(\n        data[\"reference_ionic_str_solids\"] == 0,\n        pyes_data[\"ris\"],\n        data[\"reference_ionic_str_solids\"],\n    )\n\n    data[\"dbh_params\"] = [\n        pyes_data[name] for name in [\"a\", \"b\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n    ]\n\n    data[\"distribution_opts\"] = DistributionParameters(\n        c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n        c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n        initial_log=pyes_data.get(\"initialLog\"),\n        final_log=pyes_data.get(\"finalLog\"),\n        log_increments=pyes_data.get(\"logInc\"),\n        independent_component=pyes_data.get(\"ind_comp\"),\n    )\n\n    data[\"titration_opts\"] = SimulationTitrationParameters(\n        c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n        c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n        ct=np.array(list(pyes_data[\"concModel\"][\"CT\"].values())),\n        ct_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma CT\"].values())),\n        v0=pyes_data.get(\"v0\"),\n        v_increment=pyes_data.get(\"vinc\"),\n        n_add=pyes_data.get(\"nop\"),\n    )\n    return cls(**data)\n</code></pre>"},{"location":"reference/libeq/#libeq.species_concentration","title":"species_concentration","text":"<pre><code>species_concentration(\n    concentration, log_beta, stoichiometry, full=False\n)\n</code></pre> <p>Calculate the species concentrations through the mass action law.</p> \\[ S_{i} = \\beta_i \\prod_{j=1}^{N_c} C_j^{p_{ij}} \\] <p>With \\(S_i\\) being the concentration of the species \\(i\\), \\(\\beta_i\\) the equilibrium constant of the species \\(i\\), \\(C_j\\) the concentration of the component \\(j\\), and \\(p_{ij}\\) the stoichiometric coefficient of the component \\(j\\) in the species \\(i\\).</p> <p>Parameters:</p> Name Type Description Default <code>concentration</code> <code>ndarray</code> <p>The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.</p> required <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the equilibrium constants with shape (n, s), where s is the number of solid species.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, s), where s is the number of soluble species.</p> required <code>full</code> <code>bool</code> <p>If True, return the concentrations of all species including the original concentrations. If False, return only the concentrations of the new species.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The calculated species concentrations.</p> Source code in <code>src/libeq/utils.py</code> <pre><code>def species_concentration(\n    concentration,\n    log_beta,\n    stoichiometry,\n    full=False,\n):\n    r\"\"\"\n    Calculate the species concentrations through the mass action law.\n\n    $$\n    S_{i} = \\beta_i \\prod_{j=1}^{N_c} C_j^{p_{ij}}\n    $$\n\n    With $S_i$ being the concentration of the species $i$, $\\beta_i$ the equilibrium constant of the species $i$,\n    $C_j$ the concentration of the component $j$, and $p_{ij}$ the stoichiometric coefficient of the component $j$ in the species $i$.\n\n    Parameters\n    ----------\n    concentration : numpy.ndarray\n        The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.\n    log_beta : numpy.ndarray\n        The logarithm of the equilibrium constants with shape (n, s), where s is the number of solid species.\n    stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, s), where s is the number of soluble species.\n    full : bool, optional\n        If True, return the concentrations of all species including the original concentrations.\n        If False, return only the concentrations of the new species.\n\n    Returns\n    -------\n    numpy.ndarray\n        The calculated species concentrations.\n\n    \"\"\"\n    nc = stoichiometry.shape[0]\n    _c = np.log10(concentration[:, :nc])\n\n    cext = 10 ** (log_beta + _c @ stoichiometry)\n\n    if full:\n        p = np.concatenate((concentration, cext), axis=1)\n    else:\n        p = cext\n\n    return p\n</code></pre>"},{"location":"reference/libeq/#libeq.uncertanties","title":"uncertanties","text":"<pre><code>uncertanties(\n    concentrations,\n    stoichiometry,\n    solid_stoichiometry,\n    log_b,\n    log_ks,\n    log_beta_sigma,\n    log_ks_sigma,\n    conc_sigma,\n    indepenent_comp: int | None = None,\n)\n</code></pre> <p>Calculate the uncertainties for the components and species given the input.</p> <p>Args:     concentrations (ndarray): Array of shape (n, m) representing the concentrations of the components and species.     stoichiometry (ndarray): Array of shape (n, p) representing the stoichiometric coefficients of the components and species.     solid_stoichiometry (ndarray): Array of shape (p, q) representing the stoichiometric coefficients of the solid species.     log_b (ndarray): Array of shape (n,) representing the logarithm of the beta values.     log_ks (ndarray): Array of shape (n,) representing the logarithm of the equilibrium constants.     beta_sigma (float): Standard deviation of the beta values.     ks_sigma (float): Standard deviation of the equilibrium constants.     conc_sigma (ndarray): Array of shape (n,) representing the standard deviation of the concentrations.     indepenent_comp (int | None, optional): Index of the independent component. Defaults to None.</p> <p>Returns:     tuple: A tuple containing the uncertainties for the species and solid species.</p> Source code in <code>src/libeq/errors.py</code> <pre><code>def uncertanties(\n    concentrations,\n    stoichiometry,\n    solid_stoichiometry,\n    log_b,\n    log_ks,\n    log_beta_sigma,\n    log_ks_sigma,\n    conc_sigma,\n    indepenent_comp: int | None = None,\n):\n    \"\"\"\n    Calculate the uncertainties for the components and species given the input.\n\n    Args:\n        concentrations (ndarray): Array of shape (n, m) representing the concentrations of the components and species.\n        stoichiometry (ndarray): Array of shape (n, p) representing the stoichiometric coefficients of the components and species.\n        solid_stoichiometry (ndarray): Array of shape (p, q) representing the stoichiometric coefficients of the solid species.\n        log_b (ndarray): Array of shape (n,) representing the logarithm of the beta values.\n        log_ks (ndarray): Array of shape (n,) representing the logarithm of the equilibrium constants.\n        beta_sigma (float): Standard deviation of the beta values.\n        ks_sigma (float): Standard deviation of the equilibrium constants.\n        conc_sigma (ndarray): Array of shape (n,) representing the standard deviation of the concentrations.\n        indepenent_comp (int | None, optional): Index of the independent component. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the uncertainties for the species and solid species.\n    \"\"\"\n    # Get betas from log betas\n    nc = stoichiometry.shape[0]\n    ns = stoichiometry.shape[1]\n    nf = solid_stoichiometry.shape[1]\n    num_points = concentrations.shape[0]\n    species_sigma_result = np.zeros((num_points, nc + ns))\n    solid_sigma_result = np.zeros((num_points, nf))\n    distribution = indepenent_comp is not None\n    all_beta_sigma = log_beta_sigma * np.log(10) * (10**log_b)\n    all_ks_sigma = log_ks_sigma * np.log(10) * (10**log_ks)\n\n    for point in range(num_points):\n        beta = 10 ** log_b[point]\n        ks = 10 ** log_ks[point]\n        beta_sigma = all_beta_sigma[point]\n        ks_sigma = all_ks_sigma[point]\n\n        c_free = concentrations[point, :nc]\n        c_spec = concentrations[point, nc + nf :]\n        c_solid = concentrations[point, nc : nc + nf]\n        # c_free, c_spec, c_solid = np.atleast_2d(c_free, c_spec, c_solid)\n\n        saturation_index = _compute_saturation_index(\n            c_free[np.newaxis, :], log_ks[point], solid_stoichiometry\n        )[0]\n\n        with_solids = any(c_solid &gt; 0)\n\n        to_skip = np.concatenate(([False for _ in range(nc)], c_solid == 0))\n        if with_solids:\n            nt = nc + nf\n        else:\n            nt = nc\n\n        # Define dimension of arrays required\n        M = np.zeros(shape=(nt, nt))\n\n        der_free_beta = np.zeros(shape=(nc, ns))\n        der_free_tot = np.zeros(shape=(nc, nc))\n        der_free_ks = np.zeros(shape=(nc, nf))\n\n        der_solid_beta = np.zeros(shape=(nf, ns))\n        der_solid_tot = np.zeros(shape=(nf, nc))\n        der_solid_ks = np.zeros(shape=(nf, nf))\n\n        b = -stoichiometry * (c_spec / beta)\n        d = np.identity(nc)\n        f = np.zeros(shape=(nc, nf))\n\n        # Compute common matrix term\n        M[:nc, :nc] = (\n            (\n                np.tile(c_spec, (nc, nc, 1))\n                / np.tile(c_free.reshape((nc, 1)), (nc, 1, ns))\n            )\n            * np.tile(stoichiometry, (nc, 1, 1))\n            * np.rot90(np.tile(stoichiometry, (nc, 1, 1)), -1, axes=(0, 1))\n        ).sum(axis=-1)\n        M[:nc, :nc] += d\n\n        if with_solids:\n            M[:nc, nc:nt] = solid_stoichiometry\n            M[nc:nt, :nc] = solid_stoichiometry.T * (\n                np.tile(saturation_index, (nc, 1)).T / np.tile(c_free, (nt - nc, 1))\n            )\n\n            f = np.concatenate((f, np.diag(saturation_index / ks)), axis=0)\n            b = np.concatenate(\n                (\n                    b,\n                    [[0 for _ in range(ns)] for _ in range(nf)],\n                )\n            )\n            d = np.concatenate(\n                (\n                    d,\n                    [[0 for _ in range(nc)] for _ in range(nf)],\n                )\n            )\n\n            der_solid_beta = np.delete(der_solid_beta, c_solid == 0, axis=0)\n            der_solid_tot = np.delete(der_solid_tot, c_solid == 0, axis=0)\n            der_solid_ks = np.delete(der_solid_ks, c_solid == 0, axis=0)\n\n            M = np.delete(M, to_skip, axis=0)\n            M = np.delete(M, to_skip, axis=1)\n\n            b = np.delete(b, to_skip, axis=0)\n\n            d = np.delete(d, to_skip, axis=0)\n\n            f = np.delete(f, to_skip, axis=0)\n\n        if indepenent_comp is not None:\n            M = np.delete(M, indepenent_comp, axis=0)\n            M = np.delete(M, indepenent_comp, axis=1)\n\n            b = np.delete(b, indepenent_comp, axis=0)\n            d = np.delete(d, indepenent_comp, axis=0)\n            f = np.delete(f, indepenent_comp, axis=0)\n\n            der_free_beta = np.delete(der_free_beta, indepenent_comp, 0)\n            der_free_tot = np.delete(der_free_tot, indepenent_comp, 0)\n            der_free_ks = np.delete(der_free_ks, indepenent_comp, 0)\n\n        # Solve the systems of equations\n        for i in range(ns):\n            solution = np.linalg.solve(M, b[:, i])\n            der_free_beta[:, i] = solution[: (nc - 1 if distribution else nc)]\n            if with_solids:\n                der_solid_beta[:, i] = solution[(nc - 1 if distribution else nc) :]\n\n        for r in range(nc):\n            solution = np.linalg.solve(M, d[:, r])\n            der_free_tot[:, r] = solution[: (nc - 1 if distribution else nc)]\n            if with_solids:\n                der_solid_tot[:, r] = solution[(nc - 1 if distribution else nc) :]\n\n        if with_solids:\n            for k, skip in enumerate(to_skip[-nf:]):\n                if skip:\n                    continue\n                solution = np.linalg.solve(M, f[:, k])\n                der_free_ks[:, k] = solution[: (nc - 1 if distribution else nc)]\n                der_solid_ks[:, k] = solution[(nc - 1 if distribution else nc) :]\n\n        if with_solids:\n            null_solids_index = np.nonzero(c_solid == 0)[0]\n            if null_solids_index.size:\n                der_solid_beta = np.insert(der_solid_beta, null_solids_index, 0, axis=0)\n                der_solid_tot = np.insert(der_solid_tot, null_solids_index, 0, axis=0)\n                der_solid_ks = np.insert(der_solid_ks, null_solids_index, 0, axis=0)\n\n        if distribution:\n            der_free_beta = np.insert(der_free_beta, indepenent_comp, 0, axis=0)\n            der_free_tot = np.insert(der_free_tot, indepenent_comp, 0, axis=0)\n            der_free_ks = np.insert(der_free_ks, indepenent_comp, 0, axis=0)\n\n        # Compute derivatives for the species\n        der_spec_beta = (\n            np.rot90(np.tile(stoichiometry.T, (ns, 1, 1)), -1)\n            * (\n                np.stack([np.tile(c_spec, (ns, 1)).T for _ in range(nc)], axis=-1)\n                / c_free\n            )\n            * np.tile(der_free_beta.T, (ns, 1, 1))\n        ).sum(axis=-1) + np.diag(c_spec / beta)\n\n        der_spec_tot = (\n            np.rot90(np.tile(stoichiometry.T, (nc, 1, 1)), -1)\n            * (\n                np.stack([np.tile(c_spec, (nc, 1)).T for _ in range(nc)], axis=-1)\n                / c_free\n            )\n            * np.tile(der_free_tot.T, (ns, 1, 1))\n        ).sum(axis=-1)\n\n        der_spec_ks = (\n            np.rot90(np.tile(stoichiometry.T, (nf, 1, 1)), -1)\n            * (\n                np.stack([np.tile(c_spec, (nf, 1)).T for _ in range(nc)], axis=-1)\n                / c_free\n            )\n            * np.tile(der_free_ks.T, (ns, 1, 1))\n        ).sum(axis=-1)\n\n        # Calculate uncertanity for components and species given the input\n        comp_sigma = np.sqrt(\n            ((der_free_beta**2) * (beta_sigma**2)).sum(axis=1)\n            + ((der_free_tot**2) * (conc_sigma[point] ** 2)).sum(axis=1)\n            + ((der_free_ks**2) * (ks_sigma**2)).sum(axis=1)\n        )\n\n        species_sigma = np.sqrt(\n            ((der_spec_beta**2) * (beta_sigma**2)).sum(axis=1)\n            + ((der_spec_tot**2) * (conc_sigma[point] ** 2)).sum(axis=1)\n            + ((der_spec_ks**2) * (ks_sigma**2)).sum(axis=1)\n        )\n        species_sigma = np.concatenate((comp_sigma, species_sigma))\n\n        if with_solids:\n            solid_sigma = np.sqrt(\n                ((der_solid_beta**2) * (beta_sigma**2)).sum(axis=1)\n                + ((der_solid_tot**2) * (conc_sigma[point] ** 2)).sum(axis=1)\n                + ((der_solid_ks**2) * (ks_sigma**2)).sum(axis=1)\n            )\n        else:\n            solid_sigma = np.zeros(shape=nf)\n\n        species_sigma_result[point] = species_sigma\n        solid_sigma_result[point] = solid_sigma\n\n    return species_sigma_result, solid_sigma_result\n</code></pre>"},{"location":"reference/libeq/#libeq.PotentiometryOptimizer","title":"PotentiometryOptimizer","text":"<pre><code>PotentiometryOptimizer(data: SolverData, reporter=None)\n</code></pre> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def PotentiometryOptimizer(data: SolverData, reporter=None):\n    def f_obj(c):\n        \"\"\"\n        Given the concentrations of the components, calculate the objective function value.\n\n        Parameters:\n        -------\n        x : numpy.ndarray\n            The concentrations of the components.\n\n        Returns:\n        -------\n        emf : numpy.ndarray\n            The calculcated potential from components.\n\n        \"\"\"\n        electroactive = fhsel(c)\n        calc_remf = np.log(electroactive)\n        return np.ravel(calc_remf)\n\n    def free_conc(updated_beta):\n        nonlocal _initial_guess\n        incoming_beta = updated_beta / 2.303\n        gen = ravel(data.log_beta, incoming_beta, beta_flags)\n        log_beta = np.fromiter(gen, dtype=float)\n        # Solve the system of equations\n        c, *_ = solve_equilibrium_equations(\n            stoichiometry=stoichiometry,\n            solid_stoichiometry=solid_stoichiometry,\n            original_log_beta=log_beta,\n            original_log_ks=original_log_ks,\n            total_concentration=total_concentration,\n            outer_fiexd_point_params=outer_fixed_point_params,\n            initial_guess=_initial_guess,\n            full=True,\n        )\n        _initial_guess = c[:, : stoichiometry.shape[0]]\n        return c\n\n    def jacobian(concentration):\n        \"\"\"\n        Calculate the jacobian matrix of the objective function.\n\n        Parameters:\n        -------\n        x : numpy.ndarray\n            The concentrations of the components.\n\n        Returns:\n        -------\n        jac : numpy.ndarray\n            The jacobian matrix of the objective function.\n\n        \"\"\"\n        nc = stoichiometry.shape[0]\n        J = np.zeros(shape=(concentration.shape[0], nc, nc))\n        diagonals = np.einsum(\n            \"ij,jk-&gt;ijk\", concentration[:, nc:], np.eye(concentration.shape[1] - nc)\n        )\n        # Compute Jacobian for soluble components only\n        J = stoichiometry @ diagonals @ stoichiometry.T\n        J[:, range(nc), range(nc)] += concentration[:, :nc]\n\n        B = stoichiometry[np.newaxis, ...] * concentration[..., np.newaxis, nc:]\n        dcdb = np.squeeze(np.linalg.solve(J, -B))\n        return fhsel(dcdb[..., np.flatnonzero(beta_flags)]).T\n\n    def text_reporter(*args):\n        print(f\"iteration n.{args[0]}\")\n        print(\"x\", args[1])\n        print(\"dx\", args[2])\n        print(\"sigma\", args[3])\n        print(\"----------------\\n\")\n\n    # Load the n titrations with their potential from the data file\n    emf = [t.emf for t in data.potentiometry_options.titrations]\n    emf0 = (t.e0 for t in data.potentiometry_options.titrations)\n    slope = (t.slope for t in data.potentiometry_options.titrations)\n    v_add = [t.v_add for t in data.potentiometry_options.titrations]\n\n    ll, ul = data.potentiometry_options.px_range\n\n    reduced_emf = [\n        build_reduced_emf(emf_, emf0_, slope_)\n        for emf_, emf0_, slope_ in zip(emf, emf0, slope)\n    ]\n    if ul + ll != 0:\n        idx_to_keep = [\n            (-red_emf &gt;= ll * 2.303) &amp; (-red_emf &lt;= ul * 2.303)\n            for red_emf in reduced_emf\n        ]\n        reduced_emf = [red_emf[idx] for red_emf, idx in zip(reduced_emf, idx_to_keep)]\n        emf = [emf[idx] for emf, idx in zip(emf, idx_to_keep)]\n        v_add = [v_add[idx] for v_add, idx in zip(v_add, idx_to_keep)]\n    else:\n        idx_to_keep = [None for _ in reduced_emf]\n\n    full_emf = np.concatenate(reduced_emf, axis=0).ravel()\n    n_exp_points = full_emf.shape[0]\n\n    if data.potentiometry_options.weights == \"constants\":\n        weights = np.ones(n_exp_points)\n    elif data.potentiometry_options.weights == \"calculated\":\n        e0_sigma = [t.e0_sigma for t in data.potentiometry_options.titrations]\n        v0_sigma = [t.v0_sigma for t in data.potentiometry_options.titrations]\n\n        weights = np.concatenate(\n            [\n                compute_weights(emf_, v_add_, e0_sigma_, v0_sigma_)\n                for emf_, v_add_, e0_sigma_, v0_sigma_ in zip(\n                    emf, v_add, e0_sigma, v0_sigma\n                )\n            ],\n            axis=0,\n        ).ravel()\n\n    elif data.potentiometry_options.weights == \"given\":\n        raise NotImplementedError(\"User given weights are not implemented yet.\")\n\n    slices = list(accumulate([0] + [s.shape[0] for s in reduced_emf]))\n    electro_active_components = [\n        t.electro_active_compoment for t in data.potentiometry_options.titrations\n    ]\n    fhsel = partial(hselect, hindices=electro_active_components, slices=slices[:-1])\n\n    beta_flags = np.array(data.potentiometry_options.beta_flags).astype(int)\n    beta_flags = np.where(beta_flags == -1, 0, beta_flags)\n\n    (\n        stoichiometry,\n        solid_stoichiometry,\n        original_log_beta,\n        original_log_ks,\n        charges,\n        independent_component_activity,\n    ) = _prepare_common_data(data)\n\n    total_concentration = np.vstack(\n        [\n            _titration_total_c(t, i)\n            for t, i in zip(data.potentiometry_options.titrations, idx_to_keep)\n        ]\n    )\n\n    original_log_beta = np.tile(original_log_beta, (total_concentration.shape[0], 1))\n    original_log_ks = np.tile(original_log_ks, (total_concentration.shape[0], 1))\n\n    outer_fixed_point_params = _assemble_outer_fixed_point_params(\n        data, charges, independent_component_activity\n    )\n\n    _initial_guess, *_ = solve_equilibrium_equations(\n        stoichiometry=stoichiometry,\n        solid_stoichiometry=solid_stoichiometry,\n        original_log_beta=original_log_beta,\n        original_log_ks=original_log_ks,\n        total_concentration=total_concentration,\n        outer_fiexd_point_params=outer_fixed_point_params,\n        initial_guess=None,\n        full=False,\n    )\n\n    if outer_fixed_point_params[\"ionic_strength_dependence\"] is True:\n        print(\n            \"Ionic strength dependence for potentiometry oprimization is not implemented yet.\"\n        )\n        outer_fixed_point_params[\"ionic_strength_dependence\"] = False\n\n    x, concs, return_extra = levenberg_marquardt(\n        np.fromiter(unravel(data.log_beta, beta_flags), dtype=float) * 2.303,\n        full_emf,\n        f_obj,\n        free_conc,\n        jacobian,\n        weights,\n        report=reporter,\n    )\n\n    b_error, cor_matrix, cov_matrix = fit_final_calcs(\n        return_extra[\"jacobian\"], return_extra[\"residuals\"], return_extra[\"weights\"]\n    )\n\n    return x, concs, b_error, cor_matrix, cov_matrix, return_extra\n</code></pre>"},{"location":"reference/libeq/#libeq.EqSolver","title":"EqSolver","text":"<pre><code>EqSolver(\n    data: SolverData,\n    mode: Literal[\n        \"titration\", \"distribution\"\n    ] = \"titration\",\n)\n</code></pre> <p>Solve the equilibrium equations for a given chemical system.</p> <p>The solver uses a conjuntion of methods to solve the problem at hand. In particular:</p> <ul> <li>The Positive Continious Fraction Method (PCFM) is used to presolve the equilibrium equations.</li> <li>The Newton-Raphson method is used to solve the equilibrium equations.</li> <li>The outer fixed point method is used to solve the equilibrium equations for solids.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>SolverData</code> <p>The input data containing all the necessary information for the solver.</p> required <code>mode</code> <code>(titration, distribution)</code> <p>The mode of operation for the solver. Default is \"titration\".</p> <code>\"titration\"</code> <p>Returns:</p> Name Type Description <code>result</code> <code>ndarray</code> <p>The calculated equilibrium concentrations.</p> <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the stability constants.</p> <code>log_ks</code> <code>ndarray</code> <p>The logarithm of the solubility products.</p> <code>saturation_index</code> <code>ndarray</code> <p>The calculated saturation indices for solid phases.</p> <code>total_concentration</code> <code>ndarray</code> <p>The total concentrations used in the calculations.</p> Source code in <code>src/libeq/solver/solver.py</code> <pre><code>def EqSolver(\n    data: SolverData, mode: Literal[\"titration\", \"distribution\"] = \"titration\"\n):\n    \"\"\"\n    Solve the equilibrium equations for a given chemical system.\n\n    The solver uses a conjuntion of methods to solve the problem at hand. In particular:\n\n    - The Positive Continious Fraction Method (PCFM) is used to presolve the equilibrium equations.\n    - The Newton-Raphson method is used to solve the equilibrium equations.\n    - The outer fixed point method is used to solve the equilibrium equations for solids.\n\n    Parameters\n    ----------\n    data : SolverData\n        The input data containing all the necessary information for the solver.\n    mode : {\"titration\", \"distribution\"}, optional\n        The mode of operation for the solver. Default is \"titration\".\n\n    Returns\n    -------\n    result : ndarray\n        The calculated equilibrium concentrations.\n    log_beta : ndarray\n        The logarithm of the stability constants.\n    log_ks : ndarray\n        The logarithm of the solubility products.\n    saturation_index : ndarray\n        The calculated saturation indices for solid phases.\n    total_concentration : ndarray\n        The total concentrations used in the calculations.\n    \"\"\"\n    # Get the total concentration values depending if mode is titration or distribution\n    if mode == \"titration\":\n        (\n            stoichiometry,\n            solid_stoichiometry,\n            original_log_beta,\n            original_log_ks,\n            charges,\n            independent_component_activity,\n            total_concentration,\n        ) = _prepare_titration_data(data)\n    elif mode == \"distribution\":\n        (\n            stoichiometry,\n            solid_stoichiometry,\n            original_log_beta,\n            original_log_ks,\n            charges,\n            independent_component_activity,\n            total_concentration,\n            independent_component,\n            independent_component_concentration,\n        ) = _prepare_distribution_data(data)\n    else:\n        raise ValueError(\"Invalid work mode\")\n\n    outer_fiexd_point_params = _assemble_outer_fixed_point_params(\n        data, charges, independent_component_activity\n    )\n\n    # Solve the equilibrium equations\n    result, log_beta, log_ks, saturation_index, total_concentration = (\n        solve_equilibrium_equations(\n            stoichiometry=stoichiometry,\n            solid_stoichiometry=solid_stoichiometry,\n            original_log_beta=original_log_beta,\n            original_log_ks=original_log_ks,\n            total_concentration=total_concentration,\n            outer_fiexd_point_params=outer_fiexd_point_params,\n        )\n    )\n\n    if mode == \"distribution\":\n        result, log_beta, log_ks, total_concentration = _expand_result(\n            result,\n            independent_component,\n            independent_component_concentration,\n            total_concentration,\n            log_beta,\n            log_ks,\n            data.stoichiometry,\n            data.solid_stoichiometry,\n        )\n    return result, log_beta, log_ks, saturation_index, total_concentration\n</code></pre>"},{"location":"reference/libeq/data_structure/","title":"data_structure","text":""},{"location":"reference/libeq/data_structure/#libeq.data_structure.DistributionParameters","title":"DistributionParameters","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>src/libeq/data_structure.py</code> <pre><code>class DistributionParameters(BaseModel):\n    c0: Np1DArrayFp64 | None = None\n    c0_sigma: Np1DArrayFp64 | None = None\n\n    initial_log: float | None = None\n    final_log: float | None = None\n    log_increments: float | None = None\n\n    independent_component: int | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.DistributionParameters.c0","title":"c0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c0: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.DistributionParameters.c0_sigma","title":"c0_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c0_sigma: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.DistributionParameters.initial_log","title":"initial_log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial_log: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.DistributionParameters.final_log","title":"final_log  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>final_log: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.DistributionParameters.log_increments","title":"log_increments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_increments: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.DistributionParameters.independent_component","title":"independent_component  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>independent_component: int | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.TitrationParameters","title":"TitrationParameters","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>src/libeq/data_structure.py</code> <pre><code>class TitrationParameters(BaseModel):\n    c0: Np1DArrayFp64 | None = None\n    c0_sigma: Np1DArrayFp64 | None = None\n    ct: Np1DArrayFp64 | None = None\n    ct_sigma: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.TitrationParameters.c0","title":"c0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c0: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.TitrationParameters.c0_sigma","title":"c0_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>c0_sigma: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.TitrationParameters.ct","title":"ct  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ct: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.TitrationParameters.ct_sigma","title":"ct_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ct_sigma: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SimulationTitrationParameters","title":"SimulationTitrationParameters","text":"<p>             Bases: <code>TitrationParameters</code></p> Source code in <code>src/libeq/data_structure.py</code> <pre><code>class SimulationTitrationParameters(TitrationParameters):\n    v0: float | None = None\n    v_increment: float | None = None\n    n_add: int | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SimulationTitrationParameters.v0","title":"v0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>v0: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SimulationTitrationParameters.v_increment","title":"v_increment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>v_increment: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SimulationTitrationParameters.n_add","title":"n_add  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_add: int | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters","title":"PotentiometryTitrationsParameters","text":"<p>             Bases: <code>TitrationParameters</code></p> Source code in <code>src/libeq/data_structure.py</code> <pre><code>class PotentiometryTitrationsParameters(TitrationParameters):\n    electro_active_compoment: int | None = None\n    e0: float | None = None\n    e0_sigma: float | None = None\n    slope: float | None = None\n    v0: float | None = None\n    v0_sigma: float | None = None\n    v_add: Np1DArrayFp64 | None = None\n    emf: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.electro_active_compoment","title":"electro_active_compoment  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>electro_active_compoment: int | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.e0","title":"e0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>e0: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.e0_sigma","title":"e0_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>e0_sigma: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.slope","title":"slope  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>slope: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.v0","title":"v0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>v0: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.v0_sigma","title":"v0_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>v0_sigma: float | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.v_add","title":"v_add  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>v_add: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryTitrationsParameters.emf","title":"emf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>emf: Np1DArrayFp64 | None = None\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryOptions","title":"PotentiometryOptions","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>src/libeq/data_structure.py</code> <pre><code>class PotentiometryOptions(BaseModel):\n    titrations: List[PotentiometryTitrationsParameters] = []\n    px_range: List[float] = [0, 0]\n    weights: Literal[\"constants\", \"calculated\", \"given\"] = \"constants\"\n    beta_flags: List[int] = []\n    conc_flags: List[int] = []\n    pot_flags: List[int] = []\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryOptions.titrations","title":"titrations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>titrations: List[PotentiometryTitrationsParameters] = []\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryOptions.px_range","title":"px_range  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>px_range: List[float] = [0, 0]\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryOptions.weights","title":"weights  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>weights: Literal[\"constants\", \"calculated\", \"given\"] = (\n    \"constants\"\n)\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryOptions.beta_flags","title":"beta_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>beta_flags: List[int] = []\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryOptions.conc_flags","title":"conc_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>conc_flags: List[int] = []\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.PotentiometryOptions.pot_flags","title":"pot_flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pot_flags: List[int] = []\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData","title":"SolverData","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>src/libeq/data_structure.py</code> <pre><code>class SolverData(BaseModel):\n    model_config = ConfigDict(extra=\"forbid\")\n\n    distribution_opts: DistributionParameters = DistributionParameters()\n    titration_opts: SimulationTitrationParameters = SimulationTitrationParameters()\n    potentiometry_options: PotentiometryOptions = PotentiometryOptions()\n\n    components: List[str]\n    stoichiometry: Np2DArrayInt8\n    solid_stoichiometry: Np2DArrayInt8\n    log_beta: Np1DArrayFp64\n    log_beta_sigma: Np1DArrayFp64 = np.array([])\n    log_beta_ref_dbh: Np2DArrayFp64 = np.empty((0, 2))\n    log_ks: Np1DArrayFp64 = np.array([])\n    log_ks_sigma: Np1DArrayFp64 = np.array([])\n    log_ks_ref_dbh: Np2DArrayFp64 = np.empty((0, 2))\n\n    charges: Np1DArrayFp64 = np.array([])\n\n    ionic_strength_dependence: bool = False\n    reference_ionic_str_species: Np1DArrayFp64 | float = 0\n    reference_ionic_str_solids: Np1DArrayFp64 | float = 0\n    dbh_params: Np1DArrayFp64 = np.zeros(8)\n\n    @computed_field\n    @cached_property\n    def species_charges(self) -&gt; Np1DArrayFp64:\n        return (self.stoichiometry * self.charges[:, np.newaxis]).sum(axis=0)\n\n    @computed_field\n    @cached_property\n    def solid_charges(self) -&gt; Np1DArrayFp64:\n        return (self.solid_stoichiometry * self.charges[:, np.newaxis]).sum(axis=0)\n\n    @computed_field(repr=False)\n    @cached_property\n    def z_star_species(self) -&gt; Np1DArrayFp64:\n        return (self.stoichiometry * (self.charges[:, np.newaxis] ** 2)).sum(\n            axis=0\n        ) - self.species_charges**2\n\n    @computed_field(repr=False)\n    @cached_property\n    def p_star_species(self) -&gt; Np1DArrayFp64:\n        return self.stoichiometry.sum(axis=0) - 1\n\n    @computed_field(repr=False)\n    @cached_property\n    def z_star_solids(self) -&gt; Np1DArrayFp64:\n        return (self.solid_stoichiometry * (self.charges[:, np.newaxis] ** 2)).sum(\n            axis=0\n        ) - self.solid_charges**2\n\n    @computed_field(repr=False)\n    @cached_property\n    def p_star_solids(self) -&gt; Np1DArrayFp64:\n        return self.solid_stoichiometry.sum(axis=0)\n\n    @computed_field\n    @cached_property\n    def dbh_values(self) -&gt; Dict[str, Np1DArrayFp64]:\n        result = dict()\n        for phase, iref, per_species_cde, z, p in zip(\n            (\"species\", \"solids\"),\n            (self.reference_ionic_str_species, self.reference_ionic_str_solids),\n            (self.log_beta_ref_dbh, self.log_ks_ref_dbh),\n            (self.z_star_species, self.z_star_solids),\n            (self.p_star_species, self.p_star_solids),\n        ):\n            dbh_values = dict()\n            dbh_values[\"azast\"] = self.dbh_params[0] * z\n            dbh_values[\"adh\"] = self.dbh_params[0]\n            dbh_values[\"bdh\"] = self.dbh_params[1]\n            dbh_values[\"cdh\"] = self.dbh_params[2] * p + self.dbh_params[3] * z\n            dbh_values[\"ddh\"] = self.dbh_params[4] * p + self.dbh_params[5] * z\n            dbh_values[\"edh\"] = self.dbh_params[6] * p + self.dbh_params[7] * z\n            dbh_values[\"fib\"] = np.sqrt(iref) / (1 + self.dbh_params[1] * np.sqrt(iref))\n\n            not_zero_columns = np.where(np.any(per_species_cde != 0, axis=0))[0]\n            for i in not_zero_columns:\n                dbh_values[\"cdh\"][i] = per_species_cde[0][i]\n                dbh_values[\"ddh\"][i] = per_species_cde[1][i]\n                dbh_values[\"edh\"][i] = per_species_cde[2][i]\n\n            result[phase] = dbh_values\n        return result\n\n    @computed_field\n    @cached_property\n    def species_names(self) -&gt; List[str]:\n        return self.components + _assemble_species_names(\n            self.components, self.stoichiometry\n        )\n\n    @computed_field\n    @cached_property\n    def solids_names(self) -&gt; List[str]:\n        return _assemble_species_names(self.components, self.solid_stoichiometry)\n\n    @computed_field\n    @cached_property\n    def nc(self) -&gt; int:\n        return self.stoichiometry.shape[0]\n\n    @computed_field\n    @cached_property\n    def ns(self) -&gt; int:\n        return self.stoichiometry.shape[1]\n\n    @computed_field\n    @cached_property\n    def nf(self) -&gt; int:\n        return self.solid_stoichiometry.shape[1]\n\n    @classmethod\n    def load_from_bstac(cls, file_path: str) -&gt; \"SolverData\":\n        data = dict()\n        with open(file_path, \"r\") as file:\n            lines = file.readlines()\n        parsed_data = parse_BSTAC_file(lines)\n\n        temperature = parsed_data[\"TEMP\"]\n        data[\"stoichiometry\"] = np.array(\n            [\n                [d[key] for key in d if key.startswith(\"IX\")]\n                for d in parsed_data[\"species\"]\n            ]\n        ).T\n        data[\"solid_stoichiometry\"] = np.empty(\n            (data[\"stoichiometry\"].shape[0], 0), dtype=np.int8\n        )\n        data[\"log_beta\"] = np.array([d[\"BLOG\"] for d in parsed_data[\"species\"]])\n\n        data[\"charges\"] = np.array(parsed_data.get(\"charges\", []))\n        data[\"components\"] = parsed_data[\"comp_name\"]\n        data[\"ionic_strength_dependence\"] = parsed_data[\"ICD\"] != 0\n        if data[\"ionic_strength_dependence\"]:\n            data[\"reference_ionic_str_species\"] = np.array(\n                [parsed_data[\"IREF\"] for _ in range(data[\"stoichiometry\"].shape[1])]\n            )\n            data[\"reference_ionic_str_solids\"] = np.array(\n                [\n                    parsed_data[\"IREF\"]\n                    for _ in range(data[\"solid_stoichiometry\"].shape[1])\n                ]\n            )\n            data[\"dbh_params\"] = [\n                parsed_data[i] for i in [\"AT\", \"BT\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n            ]\n\n        titration_options = [\n            PotentiometryTitrationsParameters(\n                c0=np.array([c[\"C0\"] for c in t[\"components_concentrations\"]]),\n                ct=np.array([c[\"CTT\"] for c in t[\"components_concentrations\"]]),\n                electro_active_compoment=(\n                    t[\"titration_comp_settings\"][1]\n                    if t[\"titration_comp_settings\"][1] != 0\n                    else len(data[\"components\"]) - 1\n                ),\n                e0=t[\"potential_params\"][0],\n                e0_sigma=t[\"potential_params\"][1],\n                slope=(\n                    t[\"potential_params\"][4]\n                    if t[\"potential_params\"][4] != 0\n                    else (temperature + 273.15) / 11.6048 * 2.303\n                ),\n                v0=t[\"v_params\"][0],\n                v0_sigma=t[\"v_params\"][1],\n                v_add=np.array(t[\"volume\"]),\n                emf=np.array(t[\"potential\"]),\n            )\n            for t in parsed_data[\"titrations\"]\n        ]\n\n        weights = parsed_data.get(\"MODE\", 1)\n        match weights:\n            case 0:\n                weights = \"calculated\"\n            case 1:\n                weights = \"constants\"\n            case 2:\n                weights = \"given\"\n            case _:\n                raise ValueError(\"Invalid MODE value\")\n\n        data[\"potentiometry_options\"] = PotentiometryOptions(\n            titrations=titration_options,\n            weights=weights,\n            px_range=[parsed_data[\"PHI\"], parsed_data[\"PHF\"]],\n            beta_flags=[s[\"KEY\"] for s in parsed_data[\"species\"]],\n            conc_flags=[],\n            pot_flags=[],\n        )\n        return cls(**data)\n\n    @classmethod\n    def load_from_pyes(cls, pyes_data: str | dict) -&gt; \"SolverData\":\n        if isinstance(pyes_data, str):\n            with open(pyes_data, \"r\") as file:\n                pyes_data = json.load(file)\n        data = dict()\n        data[\"components\"] = list(pyes_data[\"compModel\"][\"Name\"].values())\n\n        data[\"stoichiometry\"] = np.row_stack(\n            [\n                list(pyes_data[\"speciesModel\"][col].values())\n                for col in data[\"components\"]\n            ]\n        )\n        data[\"log_beta\"] = np.array(list(pyes_data[\"speciesModel\"][\"LogB\"].values()))\n        data[\"log_beta_sigma\"] = np.array(\n            list(pyes_data[\"speciesModel\"][\"Sigma\"].values())\n        )\n        data[\"log_beta_ref_dbh\"] = np.vstack(\n            (\n                list(pyes_data[\"speciesModel\"][\"CGF\"].values()),\n                list(pyes_data[\"speciesModel\"][\"DGF\"].values()),\n                list(pyes_data[\"speciesModel\"][\"EGF\"].values()),\n            )\n        )\n\n        data[\"solid_stoichiometry\"] = np.row_stack(\n            [\n                list(pyes_data[\"solidSpeciesModel\"][col].values())\n                for col in data[\"components\"]\n            ]\n        )\n        data[\"log_ks\"] = np.array(\n            list(pyes_data[\"solidSpeciesModel\"][\"LogKs\"].values())\n        )\n        data[\"log_ks_sigma\"] = np.array(\n            list(pyes_data[\"solidSpeciesModel\"][\"Sigma\"].values())\n        )\n        data[\"log_ks_ref_dbh\"] = np.vstack(\n            (\n                list(pyes_data[\"solidSpeciesModel\"][\"CGF\"].values()),\n                list(pyes_data[\"solidSpeciesModel\"][\"DGF\"].values()),\n                list(pyes_data[\"solidSpeciesModel\"][\"EGF\"].values()),\n            )\n        )\n\n        data[\"charges\"] = np.array(list(pyes_data[\"compModel\"][\"Charge\"].values()))\n        data[\"ionic_strength_dependence\"] = pyes_data[\"imode\"] != 0\n        data[\"reference_ionic_str_species\"] = np.array(\n            list(pyes_data[\"speciesModel\"][\"Ref. Ionic Str.\"].values())\n        )\n        data[\"reference_ionic_str_species\"] = np.where(\n            data[\"reference_ionic_str_species\"] == 0,\n            pyes_data[\"ris\"],\n            data[\"reference_ionic_str_species\"],\n        )\n\n        data[\"reference_ionic_str_solids\"] = np.array(\n            list(pyes_data[\"solidSpeciesModel\"][\"Ref. Ionic Str.\"].values())\n        )\n        data[\"reference_ionic_str_solids\"] = np.where(\n            data[\"reference_ionic_str_solids\"] == 0,\n            pyes_data[\"ris\"],\n            data[\"reference_ionic_str_solids\"],\n        )\n\n        data[\"dbh_params\"] = [\n            pyes_data[name] for name in [\"a\", \"b\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n        ]\n\n        data[\"distribution_opts\"] = DistributionParameters(\n            c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n            c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n            initial_log=pyes_data.get(\"initialLog\"),\n            final_log=pyes_data.get(\"finalLog\"),\n            log_increments=pyes_data.get(\"logInc\"),\n            independent_component=pyes_data.get(\"ind_comp\"),\n        )\n\n        data[\"titration_opts\"] = SimulationTitrationParameters(\n            c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n            c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n            ct=np.array(list(pyes_data[\"concModel\"][\"CT\"].values())),\n            ct_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma CT\"].values())),\n            v0=pyes_data.get(\"v0\"),\n            v_increment=pyes_data.get(\"vinc\"),\n            n_add=pyes_data.get(\"nop\"),\n        )\n        return cls(**data)\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(extra='forbid')\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.distribution_opts","title":"distribution_opts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>distribution_opts: DistributionParameters = (\n    DistributionParameters()\n)\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.titration_opts","title":"titration_opts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>titration_opts: SimulationTitrationParameters = (\n    SimulationTitrationParameters()\n)\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.potentiometry_options","title":"potentiometry_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>potentiometry_options: PotentiometryOptions = (\n    PotentiometryOptions()\n)\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.components","title":"components  <code>instance-attribute</code>","text":"<pre><code>components: List[str]\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.stoichiometry","title":"stoichiometry  <code>instance-attribute</code>","text":"<pre><code>stoichiometry: Np2DArrayInt8\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.solid_stoichiometry","title":"solid_stoichiometry  <code>instance-attribute</code>","text":"<pre><code>solid_stoichiometry: Np2DArrayInt8\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.log_beta","title":"log_beta  <code>instance-attribute</code>","text":"<pre><code>log_beta: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.log_beta_sigma","title":"log_beta_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_beta_sigma: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.log_beta_ref_dbh","title":"log_beta_ref_dbh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_beta_ref_dbh: Np2DArrayFp64 = empty((0, 2))\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.log_ks","title":"log_ks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_ks: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.log_ks_sigma","title":"log_ks_sigma  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_ks_sigma: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.log_ks_ref_dbh","title":"log_ks_ref_dbh  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>log_ks_ref_dbh: Np2DArrayFp64 = empty((0, 2))\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.charges","title":"charges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>charges: Np1DArrayFp64 = array([])\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.ionic_strength_dependence","title":"ionic_strength_dependence  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ionic_strength_dependence: bool = False\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.reference_ionic_str_species","title":"reference_ionic_str_species  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_ionic_str_species: Np1DArrayFp64 | float = 0\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.reference_ionic_str_solids","title":"reference_ionic_str_solids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reference_ionic_str_solids: Np1DArrayFp64 | float = 0\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.dbh_params","title":"dbh_params  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dbh_params: Np1DArrayFp64 = zeros(8)\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.species_charges","title":"species_charges  <code>cached</code> <code>property</code>","text":"<pre><code>species_charges: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.solid_charges","title":"solid_charges  <code>cached</code> <code>property</code>","text":"<pre><code>solid_charges: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.z_star_species","title":"z_star_species  <code>cached</code> <code>property</code>","text":"<pre><code>z_star_species: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.p_star_species","title":"p_star_species  <code>cached</code> <code>property</code>","text":"<pre><code>p_star_species: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.z_star_solids","title":"z_star_solids  <code>cached</code> <code>property</code>","text":"<pre><code>z_star_solids: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.p_star_solids","title":"p_star_solids  <code>cached</code> <code>property</code>","text":"<pre><code>p_star_solids: Np1DArrayFp64\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.dbh_values","title":"dbh_values  <code>cached</code> <code>property</code>","text":"<pre><code>dbh_values: Dict[str, Np1DArrayFp64]\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.species_names","title":"species_names  <code>cached</code> <code>property</code>","text":"<pre><code>species_names: List[str]\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.solids_names","title":"solids_names  <code>cached</code> <code>property</code>","text":"<pre><code>solids_names: List[str]\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.nc","title":"nc  <code>cached</code> <code>property</code>","text":"<pre><code>nc: int\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.ns","title":"ns  <code>cached</code> <code>property</code>","text":"<pre><code>ns: int\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.nf","title":"nf  <code>cached</code> <code>property</code>","text":"<pre><code>nf: int\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.load_from_bstac","title":"load_from_bstac  <code>classmethod</code>","text":"<pre><code>load_from_bstac(file_path: str) -&gt; SolverData\n</code></pre> Source code in <code>src/libeq/data_structure.py</code> <pre><code>@classmethod\ndef load_from_bstac(cls, file_path: str) -&gt; \"SolverData\":\n    data = dict()\n    with open(file_path, \"r\") as file:\n        lines = file.readlines()\n    parsed_data = parse_BSTAC_file(lines)\n\n    temperature = parsed_data[\"TEMP\"]\n    data[\"stoichiometry\"] = np.array(\n        [\n            [d[key] for key in d if key.startswith(\"IX\")]\n            for d in parsed_data[\"species\"]\n        ]\n    ).T\n    data[\"solid_stoichiometry\"] = np.empty(\n        (data[\"stoichiometry\"].shape[0], 0), dtype=np.int8\n    )\n    data[\"log_beta\"] = np.array([d[\"BLOG\"] for d in parsed_data[\"species\"]])\n\n    data[\"charges\"] = np.array(parsed_data.get(\"charges\", []))\n    data[\"components\"] = parsed_data[\"comp_name\"]\n    data[\"ionic_strength_dependence\"] = parsed_data[\"ICD\"] != 0\n    if data[\"ionic_strength_dependence\"]:\n        data[\"reference_ionic_str_species\"] = np.array(\n            [parsed_data[\"IREF\"] for _ in range(data[\"stoichiometry\"].shape[1])]\n        )\n        data[\"reference_ionic_str_solids\"] = np.array(\n            [\n                parsed_data[\"IREF\"]\n                for _ in range(data[\"solid_stoichiometry\"].shape[1])\n            ]\n        )\n        data[\"dbh_params\"] = [\n            parsed_data[i] for i in [\"AT\", \"BT\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n        ]\n\n    titration_options = [\n        PotentiometryTitrationsParameters(\n            c0=np.array([c[\"C0\"] for c in t[\"components_concentrations\"]]),\n            ct=np.array([c[\"CTT\"] for c in t[\"components_concentrations\"]]),\n            electro_active_compoment=(\n                t[\"titration_comp_settings\"][1]\n                if t[\"titration_comp_settings\"][1] != 0\n                else len(data[\"components\"]) - 1\n            ),\n            e0=t[\"potential_params\"][0],\n            e0_sigma=t[\"potential_params\"][1],\n            slope=(\n                t[\"potential_params\"][4]\n                if t[\"potential_params\"][4] != 0\n                else (temperature + 273.15) / 11.6048 * 2.303\n            ),\n            v0=t[\"v_params\"][0],\n            v0_sigma=t[\"v_params\"][1],\n            v_add=np.array(t[\"volume\"]),\n            emf=np.array(t[\"potential\"]),\n        )\n        for t in parsed_data[\"titrations\"]\n    ]\n\n    weights = parsed_data.get(\"MODE\", 1)\n    match weights:\n        case 0:\n            weights = \"calculated\"\n        case 1:\n            weights = \"constants\"\n        case 2:\n            weights = \"given\"\n        case _:\n            raise ValueError(\"Invalid MODE value\")\n\n    data[\"potentiometry_options\"] = PotentiometryOptions(\n        titrations=titration_options,\n        weights=weights,\n        px_range=[parsed_data[\"PHI\"], parsed_data[\"PHF\"]],\n        beta_flags=[s[\"KEY\"] for s in parsed_data[\"species\"]],\n        conc_flags=[],\n        pot_flags=[],\n    )\n    return cls(**data)\n</code></pre>"},{"location":"reference/libeq/data_structure/#libeq.data_structure.SolverData.load_from_pyes","title":"load_from_pyes  <code>classmethod</code>","text":"<pre><code>load_from_pyes(pyes_data: str | dict) -&gt; SolverData\n</code></pre> Source code in <code>src/libeq/data_structure.py</code> <pre><code>@classmethod\ndef load_from_pyes(cls, pyes_data: str | dict) -&gt; \"SolverData\":\n    if isinstance(pyes_data, str):\n        with open(pyes_data, \"r\") as file:\n            pyes_data = json.load(file)\n    data = dict()\n    data[\"components\"] = list(pyes_data[\"compModel\"][\"Name\"].values())\n\n    data[\"stoichiometry\"] = np.row_stack(\n        [\n            list(pyes_data[\"speciesModel\"][col].values())\n            for col in data[\"components\"]\n        ]\n    )\n    data[\"log_beta\"] = np.array(list(pyes_data[\"speciesModel\"][\"LogB\"].values()))\n    data[\"log_beta_sigma\"] = np.array(\n        list(pyes_data[\"speciesModel\"][\"Sigma\"].values())\n    )\n    data[\"log_beta_ref_dbh\"] = np.vstack(\n        (\n            list(pyes_data[\"speciesModel\"][\"CGF\"].values()),\n            list(pyes_data[\"speciesModel\"][\"DGF\"].values()),\n            list(pyes_data[\"speciesModel\"][\"EGF\"].values()),\n        )\n    )\n\n    data[\"solid_stoichiometry\"] = np.row_stack(\n        [\n            list(pyes_data[\"solidSpeciesModel\"][col].values())\n            for col in data[\"components\"]\n        ]\n    )\n    data[\"log_ks\"] = np.array(\n        list(pyes_data[\"solidSpeciesModel\"][\"LogKs\"].values())\n    )\n    data[\"log_ks_sigma\"] = np.array(\n        list(pyes_data[\"solidSpeciesModel\"][\"Sigma\"].values())\n    )\n    data[\"log_ks_ref_dbh\"] = np.vstack(\n        (\n            list(pyes_data[\"solidSpeciesModel\"][\"CGF\"].values()),\n            list(pyes_data[\"solidSpeciesModel\"][\"DGF\"].values()),\n            list(pyes_data[\"solidSpeciesModel\"][\"EGF\"].values()),\n        )\n    )\n\n    data[\"charges\"] = np.array(list(pyes_data[\"compModel\"][\"Charge\"].values()))\n    data[\"ionic_strength_dependence\"] = pyes_data[\"imode\"] != 0\n    data[\"reference_ionic_str_species\"] = np.array(\n        list(pyes_data[\"speciesModel\"][\"Ref. Ionic Str.\"].values())\n    )\n    data[\"reference_ionic_str_species\"] = np.where(\n        data[\"reference_ionic_str_species\"] == 0,\n        pyes_data[\"ris\"],\n        data[\"reference_ionic_str_species\"],\n    )\n\n    data[\"reference_ionic_str_solids\"] = np.array(\n        list(pyes_data[\"solidSpeciesModel\"][\"Ref. Ionic Str.\"].values())\n    )\n    data[\"reference_ionic_str_solids\"] = np.where(\n        data[\"reference_ionic_str_solids\"] == 0,\n        pyes_data[\"ris\"],\n        data[\"reference_ionic_str_solids\"],\n    )\n\n    data[\"dbh_params\"] = [\n        pyes_data[name] for name in [\"a\", \"b\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\"]\n    ]\n\n    data[\"distribution_opts\"] = DistributionParameters(\n        c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n        c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n        initial_log=pyes_data.get(\"initialLog\"),\n        final_log=pyes_data.get(\"finalLog\"),\n        log_increments=pyes_data.get(\"logInc\"),\n        independent_component=pyes_data.get(\"ind_comp\"),\n    )\n\n    data[\"titration_opts\"] = SimulationTitrationParameters(\n        c0=np.array(list(pyes_data[\"concModel\"][\"C0\"].values())),\n        c0_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma C0\"].values())),\n        ct=np.array(list(pyes_data[\"concModel\"][\"CT\"].values())),\n        ct_sigma=np.array(list(pyes_data[\"concModel\"][\"Sigma CT\"].values())),\n        v0=pyes_data.get(\"v0\"),\n        v_increment=pyes_data.get(\"vinc\"),\n        n_add=pyes_data.get(\"nop\"),\n    )\n    return cls(**data)\n</code></pre>"},{"location":"reference/libeq/errors/","title":"errors","text":""},{"location":"reference/libeq/errors/#libeq.errors.uncertanties","title":"uncertanties","text":"<pre><code>uncertanties(\n    concentrations,\n    stoichiometry,\n    solid_stoichiometry,\n    log_b,\n    log_ks,\n    log_beta_sigma,\n    log_ks_sigma,\n    conc_sigma,\n    indepenent_comp: int | None = None,\n)\n</code></pre> <p>Calculate the uncertainties for the components and species given the input.</p> <p>Args:     concentrations (ndarray): Array of shape (n, m) representing the concentrations of the components and species.     stoichiometry (ndarray): Array of shape (n, p) representing the stoichiometric coefficients of the components and species.     solid_stoichiometry (ndarray): Array of shape (p, q) representing the stoichiometric coefficients of the solid species.     log_b (ndarray): Array of shape (n,) representing the logarithm of the beta values.     log_ks (ndarray): Array of shape (n,) representing the logarithm of the equilibrium constants.     beta_sigma (float): Standard deviation of the beta values.     ks_sigma (float): Standard deviation of the equilibrium constants.     conc_sigma (ndarray): Array of shape (n,) representing the standard deviation of the concentrations.     indepenent_comp (int | None, optional): Index of the independent component. Defaults to None.</p> <p>Returns:     tuple: A tuple containing the uncertainties for the species and solid species.</p> Source code in <code>src/libeq/errors.py</code> <pre><code>def uncertanties(\n    concentrations,\n    stoichiometry,\n    solid_stoichiometry,\n    log_b,\n    log_ks,\n    log_beta_sigma,\n    log_ks_sigma,\n    conc_sigma,\n    indepenent_comp: int | None = None,\n):\n    \"\"\"\n    Calculate the uncertainties for the components and species given the input.\n\n    Args:\n        concentrations (ndarray): Array of shape (n, m) representing the concentrations of the components and species.\n        stoichiometry (ndarray): Array of shape (n, p) representing the stoichiometric coefficients of the components and species.\n        solid_stoichiometry (ndarray): Array of shape (p, q) representing the stoichiometric coefficients of the solid species.\n        log_b (ndarray): Array of shape (n,) representing the logarithm of the beta values.\n        log_ks (ndarray): Array of shape (n,) representing the logarithm of the equilibrium constants.\n        beta_sigma (float): Standard deviation of the beta values.\n        ks_sigma (float): Standard deviation of the equilibrium constants.\n        conc_sigma (ndarray): Array of shape (n,) representing the standard deviation of the concentrations.\n        indepenent_comp (int | None, optional): Index of the independent component. Defaults to None.\n\n    Returns:\n        tuple: A tuple containing the uncertainties for the species and solid species.\n    \"\"\"\n    # Get betas from log betas\n    nc = stoichiometry.shape[0]\n    ns = stoichiometry.shape[1]\n    nf = solid_stoichiometry.shape[1]\n    num_points = concentrations.shape[0]\n    species_sigma_result = np.zeros((num_points, nc + ns))\n    solid_sigma_result = np.zeros((num_points, nf))\n    distribution = indepenent_comp is not None\n    all_beta_sigma = log_beta_sigma * np.log(10) * (10**log_b)\n    all_ks_sigma = log_ks_sigma * np.log(10) * (10**log_ks)\n\n    for point in range(num_points):\n        beta = 10 ** log_b[point]\n        ks = 10 ** log_ks[point]\n        beta_sigma = all_beta_sigma[point]\n        ks_sigma = all_ks_sigma[point]\n\n        c_free = concentrations[point, :nc]\n        c_spec = concentrations[point, nc + nf :]\n        c_solid = concentrations[point, nc : nc + nf]\n        # c_free, c_spec, c_solid = np.atleast_2d(c_free, c_spec, c_solid)\n\n        saturation_index = _compute_saturation_index(\n            c_free[np.newaxis, :], log_ks[point], solid_stoichiometry\n        )[0]\n\n        with_solids = any(c_solid &gt; 0)\n\n        to_skip = np.concatenate(([False for _ in range(nc)], c_solid == 0))\n        if with_solids:\n            nt = nc + nf\n        else:\n            nt = nc\n\n        # Define dimension of arrays required\n        M = np.zeros(shape=(nt, nt))\n\n        der_free_beta = np.zeros(shape=(nc, ns))\n        der_free_tot = np.zeros(shape=(nc, nc))\n        der_free_ks = np.zeros(shape=(nc, nf))\n\n        der_solid_beta = np.zeros(shape=(nf, ns))\n        der_solid_tot = np.zeros(shape=(nf, nc))\n        der_solid_ks = np.zeros(shape=(nf, nf))\n\n        b = -stoichiometry * (c_spec / beta)\n        d = np.identity(nc)\n        f = np.zeros(shape=(nc, nf))\n\n        # Compute common matrix term\n        M[:nc, :nc] = (\n            (\n                np.tile(c_spec, (nc, nc, 1))\n                / np.tile(c_free.reshape((nc, 1)), (nc, 1, ns))\n            )\n            * np.tile(stoichiometry, (nc, 1, 1))\n            * np.rot90(np.tile(stoichiometry, (nc, 1, 1)), -1, axes=(0, 1))\n        ).sum(axis=-1)\n        M[:nc, :nc] += d\n\n        if with_solids:\n            M[:nc, nc:nt] = solid_stoichiometry\n            M[nc:nt, :nc] = solid_stoichiometry.T * (\n                np.tile(saturation_index, (nc, 1)).T / np.tile(c_free, (nt - nc, 1))\n            )\n\n            f = np.concatenate((f, np.diag(saturation_index / ks)), axis=0)\n            b = np.concatenate(\n                (\n                    b,\n                    [[0 for _ in range(ns)] for _ in range(nf)],\n                )\n            )\n            d = np.concatenate(\n                (\n                    d,\n                    [[0 for _ in range(nc)] for _ in range(nf)],\n                )\n            )\n\n            der_solid_beta = np.delete(der_solid_beta, c_solid == 0, axis=0)\n            der_solid_tot = np.delete(der_solid_tot, c_solid == 0, axis=0)\n            der_solid_ks = np.delete(der_solid_ks, c_solid == 0, axis=0)\n\n            M = np.delete(M, to_skip, axis=0)\n            M = np.delete(M, to_skip, axis=1)\n\n            b = np.delete(b, to_skip, axis=0)\n\n            d = np.delete(d, to_skip, axis=0)\n\n            f = np.delete(f, to_skip, axis=0)\n\n        if indepenent_comp is not None:\n            M = np.delete(M, indepenent_comp, axis=0)\n            M = np.delete(M, indepenent_comp, axis=1)\n\n            b = np.delete(b, indepenent_comp, axis=0)\n            d = np.delete(d, indepenent_comp, axis=0)\n            f = np.delete(f, indepenent_comp, axis=0)\n\n            der_free_beta = np.delete(der_free_beta, indepenent_comp, 0)\n            der_free_tot = np.delete(der_free_tot, indepenent_comp, 0)\n            der_free_ks = np.delete(der_free_ks, indepenent_comp, 0)\n\n        # Solve the systems of equations\n        for i in range(ns):\n            solution = np.linalg.solve(M, b[:, i])\n            der_free_beta[:, i] = solution[: (nc - 1 if distribution else nc)]\n            if with_solids:\n                der_solid_beta[:, i] = solution[(nc - 1 if distribution else nc) :]\n\n        for r in range(nc):\n            solution = np.linalg.solve(M, d[:, r])\n            der_free_tot[:, r] = solution[: (nc - 1 if distribution else nc)]\n            if with_solids:\n                der_solid_tot[:, r] = solution[(nc - 1 if distribution else nc) :]\n\n        if with_solids:\n            for k, skip in enumerate(to_skip[-nf:]):\n                if skip:\n                    continue\n                solution = np.linalg.solve(M, f[:, k])\n                der_free_ks[:, k] = solution[: (nc - 1 if distribution else nc)]\n                der_solid_ks[:, k] = solution[(nc - 1 if distribution else nc) :]\n\n        if with_solids:\n            null_solids_index = np.nonzero(c_solid == 0)[0]\n            if null_solids_index.size:\n                der_solid_beta = np.insert(der_solid_beta, null_solids_index, 0, axis=0)\n                der_solid_tot = np.insert(der_solid_tot, null_solids_index, 0, axis=0)\n                der_solid_ks = np.insert(der_solid_ks, null_solids_index, 0, axis=0)\n\n        if distribution:\n            der_free_beta = np.insert(der_free_beta, indepenent_comp, 0, axis=0)\n            der_free_tot = np.insert(der_free_tot, indepenent_comp, 0, axis=0)\n            der_free_ks = np.insert(der_free_ks, indepenent_comp, 0, axis=0)\n\n        # Compute derivatives for the species\n        der_spec_beta = (\n            np.rot90(np.tile(stoichiometry.T, (ns, 1, 1)), -1)\n            * (\n                np.stack([np.tile(c_spec, (ns, 1)).T for _ in range(nc)], axis=-1)\n                / c_free\n            )\n            * np.tile(der_free_beta.T, (ns, 1, 1))\n        ).sum(axis=-1) + np.diag(c_spec / beta)\n\n        der_spec_tot = (\n            np.rot90(np.tile(stoichiometry.T, (nc, 1, 1)), -1)\n            * (\n                np.stack([np.tile(c_spec, (nc, 1)).T for _ in range(nc)], axis=-1)\n                / c_free\n            )\n            * np.tile(der_free_tot.T, (ns, 1, 1))\n        ).sum(axis=-1)\n\n        der_spec_ks = (\n            np.rot90(np.tile(stoichiometry.T, (nf, 1, 1)), -1)\n            * (\n                np.stack([np.tile(c_spec, (nf, 1)).T for _ in range(nc)], axis=-1)\n                / c_free\n            )\n            * np.tile(der_free_ks.T, (ns, 1, 1))\n        ).sum(axis=-1)\n\n        # Calculate uncertanity for components and species given the input\n        comp_sigma = np.sqrt(\n            ((der_free_beta**2) * (beta_sigma**2)).sum(axis=1)\n            + ((der_free_tot**2) * (conc_sigma[point] ** 2)).sum(axis=1)\n            + ((der_free_ks**2) * (ks_sigma**2)).sum(axis=1)\n        )\n\n        species_sigma = np.sqrt(\n            ((der_spec_beta**2) * (beta_sigma**2)).sum(axis=1)\n            + ((der_spec_tot**2) * (conc_sigma[point] ** 2)).sum(axis=1)\n            + ((der_spec_ks**2) * (ks_sigma**2)).sum(axis=1)\n        )\n        species_sigma = np.concatenate((comp_sigma, species_sigma))\n\n        if with_solids:\n            solid_sigma = np.sqrt(\n                ((der_solid_beta**2) * (beta_sigma**2)).sum(axis=1)\n                + ((der_solid_tot**2) * (conc_sigma[point] ** 2)).sum(axis=1)\n                + ((der_solid_ks**2) * (ks_sigma**2)).sum(axis=1)\n            )\n        else:\n            solid_sigma = np.zeros(shape=nf)\n\n        species_sigma_result[point] = species_sigma\n        solid_sigma_result[point] = solid_sigma\n\n    return species_sigma_result, solid_sigma_result\n</code></pre>"},{"location":"reference/libeq/excepts/","title":"excepts","text":""},{"location":"reference/libeq/excepts/#libeq.excepts.FailedCalculateConcentrations","title":"FailedCalculateConcentrations","text":"<p>             Bases: <code>Exception</code></p> <p>When calculation of concentrations fails.</p> Source code in <code>src/libeq/excepts.py</code> <pre><code>class FailedCalculateConcentrations(Exception):\n    \"\"\"When calculation of concentrations fails.\"\"\"\n\n    def __init__(self, msg, last_value, **diagn):\n        super().__init__()\n        self.msg = msg\n        self.last_value = last_value\n        self.diagnostic = diagn\n\n    def __str__(self):\n        return self.msg\n</code></pre>"},{"location":"reference/libeq/excepts/#libeq.excepts.FailedCalculateConcentrations.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg = msg\n</code></pre>"},{"location":"reference/libeq/excepts/#libeq.excepts.FailedCalculateConcentrations.last_value","title":"last_value  <code>instance-attribute</code>","text":"<pre><code>last_value = last_value\n</code></pre>"},{"location":"reference/libeq/excepts/#libeq.excepts.FailedCalculateConcentrations.diagnostic","title":"diagnostic  <code>instance-attribute</code>","text":"<pre><code>diagnostic = diagn\n</code></pre>"},{"location":"reference/libeq/excepts/#libeq.excepts.NotConvergenceException","title":"NotConvergenceException","text":"<p>             Bases: <code>Exception</code></p> <p>When convergence is not reached.</p> <p>It contains the last value of the iterations in case this information can be valuable.</p> Source code in <code>src/libeq/excepts.py</code> <pre><code>class NotConvergenceException(Exception):\n    \"\"\"When convergence is not reached.\n\n    It contains the last value of the iterations in case this information can\n    be valuable.\n    \"\"\"\n\n    def __init__(self, msg, last_value):\n        super().__init__()\n        self.msg = msg\n        self.last_value = last_value\n\n    def __str__(self):\n        return self.msg\n</code></pre>"},{"location":"reference/libeq/excepts/#libeq.excepts.NotConvergenceException.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg = msg\n</code></pre>"},{"location":"reference/libeq/excepts/#libeq.excepts.NotConvergenceException.last_value","title":"last_value  <code>instance-attribute</code>","text":"<pre><code>last_value = last_value\n</code></pre>"},{"location":"reference/libeq/excepts/#libeq.excepts.TooManyIterations","title":"TooManyIterations","text":"<p>             Bases: <code>NotConvergenceException</code></p> <p>When maximum number of iterations is reached.</p> <p>This exception is thrown when the maximum number of iterations has been reached without meeting the convergence criteria</p> Source code in <code>src/libeq/excepts.py</code> <pre><code>class TooManyIterations(NotConvergenceException):\n    \"\"\"When maximum number of iterations is reached.\n\n    This exception is thrown when the maximum number of iterations\n    has been reached without meeting the convergence criteria\n    \"\"\"\n</code></pre>"},{"location":"reference/libeq/utils/","title":"utils","text":""},{"location":"reference/libeq/utils/#libeq.utils.species_concentration","title":"species_concentration","text":"<pre><code>species_concentration(\n    concentration, log_beta, stoichiometry, full=False\n)\n</code></pre> <p>Calculate the species concentrations through the mass action law.</p> \\[ S_{i} = \\beta_i \\prod_{j=1}^{N_c} C_j^{p_{ij}} \\] <p>With \\(S_i\\) being the concentration of the species \\(i\\), \\(\\beta_i\\) the equilibrium constant of the species \\(i\\), \\(C_j\\) the concentration of the component \\(j\\), and \\(p_{ij}\\) the stoichiometric coefficient of the component \\(j\\) in the species \\(i\\).</p> <p>Parameters:</p> Name Type Description Default <code>concentration</code> <code>ndarray</code> <p>The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.</p> required <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the equilibrium constants with shape (n, s), where s is the number of solid species.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, s), where s is the number of soluble species.</p> required <code>full</code> <code>bool</code> <p>If True, return the concentrations of all species including the original concentrations. If False, return only the concentrations of the new species.</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The calculated species concentrations.</p> Source code in <code>src/libeq/utils.py</code> <pre><code>def species_concentration(\n    concentration,\n    log_beta,\n    stoichiometry,\n    full=False,\n):\n    r\"\"\"\n    Calculate the species concentrations through the mass action law.\n\n    $$\n    S_{i} = \\beta_i \\prod_{j=1}^{N_c} C_j^{p_{ij}}\n    $$\n\n    With $S_i$ being the concentration of the species $i$, $\\beta_i$ the equilibrium constant of the species $i$,\n    $C_j$ the concentration of the component $j$, and $p_{ij}$ the stoichiometric coefficient of the component $j$ in the species $i$.\n\n    Parameters\n    ----------\n    concentration : numpy.ndarray\n        The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.\n    log_beta : numpy.ndarray\n        The logarithm of the equilibrium constants with shape (n, s), where s is the number of solid species.\n    stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, s), where s is the number of soluble species.\n    full : bool, optional\n        If True, return the concentrations of all species including the original concentrations.\n        If False, return only the concentrations of the new species.\n\n    Returns\n    -------\n    numpy.ndarray\n        The calculated species concentrations.\n\n    \"\"\"\n    nc = stoichiometry.shape[0]\n    _c = np.log10(concentration[:, :nc])\n\n    cext = 10 ** (log_beta + _c @ stoichiometry)\n\n    if full:\n        p = np.concatenate((concentration, cext), axis=1)\n    else:\n        p = cext\n\n    return p\n</code></pre>"},{"location":"reference/libeq/optimizers/","title":"optimizers","text":""},{"location":"reference/libeq/optimizers/fitter/","title":"fitter","text":""},{"location":"reference/libeq/optimizers/fitter/#libeq.optimizers.fitter.levenberg_marquardt","title":"levenberg_marquardt","text":"<pre><code>levenberg_marquardt(\n    x0,\n    y,\n    f,\n    free_conc,\n    jacobian,\n    weights,\n    capping=None,\n    **kwargs\n)\n</code></pre> <p>Non linear fitting by means of the Levenberg-Marquardt method.</p> <p>Parameters:     x0 (:class:<code>numpy.ndarray</code>): initial guess.     y (:class:<code>numpy.ndarray</code>): the experimental magnitude to be fitted.         If must be a 1D-shaped array.     weights (1D-array of floats): containing the values for weighting. It         must be the same shape and type as y.     f (callable): A function that accepts the values of x0 as well as         the free concentrations and return the calculated values for y.         The returned array must be the same shape and type as y.     free_conc (callable): A function that accepts x0 and returns the         values of the free concentration.     jacobian (callable): A function that accepts x0 and the free         concentration array and returns the jacobian matrix.     max_iterations (int, optional): maximum number of iterations allowed     threshold (float, optional): criteria for convergence     out_chisq (list, optional): If provided, the successive values for         \u03c7\u00b2 in each iteration will be stored.     verbosity (int, optional): An 0-2 number indicating the level of         verbosity to be printed. 0 for mute, 1 for normal and 2 for         pedantic output.     report (callable, optional): A callable function that accepts the         values of x0, iteration counter, free concentration values,         etc., and is called every iteration in order to report on the         progress of the fitting.     one_iter (bool, optional): Performs one iterations and returns the         result.     quiet_maxits (bool, optional): Prevents this funcyion from throwing         :class:<code>excepts.TooManyIterations</code> and quietly exits and returns         the result when the maximum number of iterations is reached.</p> <p>Returns:     tuple:     - :class:<code>numpy.ndarray</code>: The refined constants in natural logarithmic         units     - :class:<code>numpy.ndarray</code>: The free concentrations     - dict: Extra optional parameters</p> <p>Raises:     ValueError: If invalid parameters are passed.</p> Source code in <code>src/libeq/optimizers/fitter.py</code> <pre><code>def levenberg_marquardt(x0, y, f, free_conc, jacobian, weights, capping=None, **kwargs):\n    r\"\"\"Non linear fitting by means of the Levenberg-Marquardt method.\n\n    Parameters:\n        x0 (:class:`numpy.ndarray`): initial guess.\n        y (:class:`numpy.ndarray`): the experimental magnitude to be fitted.\n            If must be a 1D-shaped array.\n        weights (1D-array of floats): containing the values for weighting. It\n            must be the same shape and type as *y*.\n        f (callable): A function that accepts the values of *x0* as well as\n            the free concentrations and return the calculated values for *y*.\n            The returned array must be the same shape and type as *y*.\n        free_conc (callable): A function that accepts *x0* and returns the\n            values of the free concentration.\n        jacobian (callable): A function that accepts *x0* and the free\n            concentration array and returns the jacobian matrix.\n        max_iterations (int, optional): maximum number of iterations allowed\n        threshold (float, optional): criteria for convergence\n        out_chisq (list, optional): If provided, the successive values for\n            \u03c7\u00b2 in each iteration will be stored.\n        verbosity (int, optional): An 0-2 number indicating the level of\n            verbosity to be printed. 0 for mute, 1 for normal and 2 for\n            pedantic output.\n        report (callable, optional): A callable function that accepts the\n            values of x0, iteration counter, free concentration values,\n            etc., and is called every iteration in order to report on the\n            progress of the fitting.\n        one_iter (bool, optional): Performs one iterations and returns the\n            result.\n        quiet_maxits (bool, optional): Prevents this funcyion from throwing\n            :class:`excepts.TooManyIterations` and quietly exits and returns\n            the result when the maximum number of iterations is reached.\n\n    Returns:\n        tuple:\n        - :class:`numpy.ndarray`: The refined constants in natural logarithmic\n            units\n        - :class:`numpy.ndarray`: The free concentrations\n        - dict: Extra optional parameters\n\n    Raises:\n        ValueError: If invalid parameters are passed.\n    \"\"\"\n\n    def _report(*kws):\n        if report is not None:\n            report(*kws)\n\n    report = kwargs.get(\"report\", None)\n    one_iter = kwargs.get(\"one_iter\", False)\n    threshold = kwargs.pop(\"threshold\", 1e-5)\n    max_iterations = kwargs.pop(\"max_iterations\", 100)\n    quiet_maxits = kwargs.get(\"quiet_maxits\", False)\n    damping = kwargs.pop(\"damping\", 0)\n    fcapping = trivial_capping if capping is None else capping\n\n    n_points = len(y)\n    n_vars = len(x0)\n    sigma_hist = []\n\n    # import pudb\n    # pudb.set_trace()\n\n    iterations = 1\n    W = np.diag(weights)\n    # assert W.shape == (n_points, n_points)\n\n    x = np.copy(x0)\n    concs = free_conc(x)\n    # assert len(concs) == n_points\n    y_calc = f(concs)\n    # assert y_calc.shape == y.shape\n\n    # compute \u03c7\u2082(dx)\n    prev_resid = y - y_calc\n    resid = y - y_calc\n    sigma = fit_sigma(resid, weights, n_points, n_vars)\n    while True:\n        J = jacobian(concs)\n        M = np.dot(np.dot(J.T, W), J)\n        D = np.diag(np.diag(M))\n        V = np.dot(np.dot(J.T, W), resid)\n\n        try:\n            dx = np.linalg.solve(M + damping * D, V)\n        except np.linalg.linalg.LinAlgError:\n            damping *= 10\n            continue\n\n        new_x = fcapping(x, dx)\n        new_concs = free_conc(new_x)\n        y_calc = f(new_concs)\n        resid = y - y_calc\n\n        sigma = fit_sigma(resid, weights, n_points, n_vars)\n        old_sum_squares = weighted_sum_squares(prev_resid, weights)\n        sum_squares = weighted_sum_squares(resid, weights)\n        diff_ss = old_sum_squares - sum_squares\n\n        _report(iterations, x / 2.303, dx / 2.303, sigma)\n\n        if one_iter:\n            break\n\n        std_dev = np.diag(np.linalg.inv(M))\n        beta_sigma = np.sqrt(np.abs(std_dev)) * sigma\n\n        if (\n            np.all(np.abs(dx / beta_sigma) &lt; 0.1)\n            or np.abs(diff_ss / sum_squares) &lt; threshold\n        ):\n            break\n        else:\n            predicted_diff_ss = 2 * dx.T @ V - dx.T @ (M) @ dx\n            reduction_ratio = diff_ss / predicted_diff_ss\n\n            if reduction_ratio &lt; 0.25:\n                a = 1 / ((2 - diff_ss) / (dx @ V))\n                v = np.clip(1 / a, 2, 10)\n                if damping == 0:\n                    damping = 1 / np.trace(M)\n                    v /= 2\n                damping *= v\n\n            elif reduction_ratio &gt; 0.75:\n                damping /= 2\n\n        x = new_x\n        concs = new_concs\n        prev_resid = resid\n        sigma_hist.append(sigma)\n\n        iterations += 1\n\n        if iterations &gt; max_iterations:\n            if quiet_maxits:\n                break\n\n            ret = {\n                \"last_value\": x,\n                \"jacobian\": J,\n                \"weights\": W,\n                \"residuals\": resid,\n                \"concentrations\": concs,\n                \"damping\": damping,\n                \"sigma\": sigma_hist,\n                \"iterations\": iterations,\n            }\n            raise TooManyIterations(\n                msg=(\"Maximum number of\" \"iterations reached\"), last_value=ret\n            )\n\n    ret_extra = {\n        \"jacobian\": J,\n        \"weights\": W,\n        \"residuals\": resid,\n        \"damping\": damping,\n        \"sigma\": sigma_hist,\n        \"iterations\": iterations,\n    }\n    return x / 2.303, concs, ret_extra\n</code></pre>"},{"location":"reference/libeq/optimizers/fitter/#libeq.optimizers.fitter.trivial_capping","title":"trivial_capping","text":"<pre><code>trivial_capping(x, dx)\n</code></pre> <p>Capping function where there is no capping</p> Source code in <code>src/libeq/optimizers/fitter.py</code> <pre><code>def trivial_capping(x, dx):\n    \"Capping function where there is no capping\"\n    return x + dx\n</code></pre>"},{"location":"reference/libeq/optimizers/fitter/#libeq.optimizers.fitter.max_ratio_capping","title":"max_ratio_capping","text":"<pre><code>max_ratio_capping(x, dx, ratio)\n</code></pre> <p>Capping to a fraction of change</p> Source code in <code>src/libeq/optimizers/fitter.py</code> <pre><code>def max_ratio_capping(x, dx, ratio):\n    \"Capping to a fraction of change\"\n    aux = np.abs(dx) / x\n    return np.where(aux &gt; ratio, np.sign(dx) * (1 + ratio) * x, x + dx)\n</code></pre>"},{"location":"reference/libeq/optimizers/fitter/#libeq.optimizers.fitter.fit_sigma","title":"fit_sigma","text":"<pre><code>fit_sigma(residuals, weights, npoints, nparams)\n</code></pre> Source code in <code>src/libeq/optimizers/fitter.py</code> <pre><code>def fit_sigma(residuals, weights, npoints, nparams):\n    return np.sqrt(weighted_sum_squares(residuals, weights) / (npoints - nparams))\n</code></pre>"},{"location":"reference/libeq/optimizers/fitter/#libeq.optimizers.fitter.weighted_sum_squares","title":"weighted_sum_squares","text":"<pre><code>weighted_sum_squares(residuals, weights)\n</code></pre> Source code in <code>src/libeq/optimizers/fitter.py</code> <pre><code>def weighted_sum_squares(residuals, weights):\n    return np.sum(weights * residuals**2)\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/","title":"potentiometry","text":""},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.PotentiometryOptimizer","title":"PotentiometryOptimizer","text":"<pre><code>PotentiometryOptimizer(data: SolverData, reporter=None)\n</code></pre> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def PotentiometryOptimizer(data: SolverData, reporter=None):\n    def f_obj(c):\n        \"\"\"\n        Given the concentrations of the components, calculate the objective function value.\n\n        Parameters:\n        -------\n        x : numpy.ndarray\n            The concentrations of the components.\n\n        Returns:\n        -------\n        emf : numpy.ndarray\n            The calculcated potential from components.\n\n        \"\"\"\n        electroactive = fhsel(c)\n        calc_remf = np.log(electroactive)\n        return np.ravel(calc_remf)\n\n    def free_conc(updated_beta):\n        nonlocal _initial_guess\n        incoming_beta = updated_beta / 2.303\n        gen = ravel(data.log_beta, incoming_beta, beta_flags)\n        log_beta = np.fromiter(gen, dtype=float)\n        # Solve the system of equations\n        c, *_ = solve_equilibrium_equations(\n            stoichiometry=stoichiometry,\n            solid_stoichiometry=solid_stoichiometry,\n            original_log_beta=log_beta,\n            original_log_ks=original_log_ks,\n            total_concentration=total_concentration,\n            outer_fiexd_point_params=outer_fixed_point_params,\n            initial_guess=_initial_guess,\n            full=True,\n        )\n        _initial_guess = c[:, : stoichiometry.shape[0]]\n        return c\n\n    def jacobian(concentration):\n        \"\"\"\n        Calculate the jacobian matrix of the objective function.\n\n        Parameters:\n        -------\n        x : numpy.ndarray\n            The concentrations of the components.\n\n        Returns:\n        -------\n        jac : numpy.ndarray\n            The jacobian matrix of the objective function.\n\n        \"\"\"\n        nc = stoichiometry.shape[0]\n        J = np.zeros(shape=(concentration.shape[0], nc, nc))\n        diagonals = np.einsum(\n            \"ij,jk-&gt;ijk\", concentration[:, nc:], np.eye(concentration.shape[1] - nc)\n        )\n        # Compute Jacobian for soluble components only\n        J = stoichiometry @ diagonals @ stoichiometry.T\n        J[:, range(nc), range(nc)] += concentration[:, :nc]\n\n        B = stoichiometry[np.newaxis, ...] * concentration[..., np.newaxis, nc:]\n        dcdb = np.squeeze(np.linalg.solve(J, -B))\n        return fhsel(dcdb[..., np.flatnonzero(beta_flags)]).T\n\n    def text_reporter(*args):\n        print(f\"iteration n.{args[0]}\")\n        print(\"x\", args[1])\n        print(\"dx\", args[2])\n        print(\"sigma\", args[3])\n        print(\"----------------\\n\")\n\n    # Load the n titrations with their potential from the data file\n    emf = [t.emf for t in data.potentiometry_options.titrations]\n    emf0 = (t.e0 for t in data.potentiometry_options.titrations)\n    slope = (t.slope for t in data.potentiometry_options.titrations)\n    v_add = [t.v_add for t in data.potentiometry_options.titrations]\n\n    ll, ul = data.potentiometry_options.px_range\n\n    reduced_emf = [\n        build_reduced_emf(emf_, emf0_, slope_)\n        for emf_, emf0_, slope_ in zip(emf, emf0, slope)\n    ]\n    if ul + ll != 0:\n        idx_to_keep = [\n            (-red_emf &gt;= ll * 2.303) &amp; (-red_emf &lt;= ul * 2.303)\n            for red_emf in reduced_emf\n        ]\n        reduced_emf = [red_emf[idx] for red_emf, idx in zip(reduced_emf, idx_to_keep)]\n        emf = [emf[idx] for emf, idx in zip(emf, idx_to_keep)]\n        v_add = [v_add[idx] for v_add, idx in zip(v_add, idx_to_keep)]\n    else:\n        idx_to_keep = [None for _ in reduced_emf]\n\n    full_emf = np.concatenate(reduced_emf, axis=0).ravel()\n    n_exp_points = full_emf.shape[0]\n\n    if data.potentiometry_options.weights == \"constants\":\n        weights = np.ones(n_exp_points)\n    elif data.potentiometry_options.weights == \"calculated\":\n        e0_sigma = [t.e0_sigma for t in data.potentiometry_options.titrations]\n        v0_sigma = [t.v0_sigma for t in data.potentiometry_options.titrations]\n\n        weights = np.concatenate(\n            [\n                compute_weights(emf_, v_add_, e0_sigma_, v0_sigma_)\n                for emf_, v_add_, e0_sigma_, v0_sigma_ in zip(\n                    emf, v_add, e0_sigma, v0_sigma\n                )\n            ],\n            axis=0,\n        ).ravel()\n\n    elif data.potentiometry_options.weights == \"given\":\n        raise NotImplementedError(\"User given weights are not implemented yet.\")\n\n    slices = list(accumulate([0] + [s.shape[0] for s in reduced_emf]))\n    electro_active_components = [\n        t.electro_active_compoment for t in data.potentiometry_options.titrations\n    ]\n    fhsel = partial(hselect, hindices=electro_active_components, slices=slices[:-1])\n\n    beta_flags = np.array(data.potentiometry_options.beta_flags).astype(int)\n    beta_flags = np.where(beta_flags == -1, 0, beta_flags)\n\n    (\n        stoichiometry,\n        solid_stoichiometry,\n        original_log_beta,\n        original_log_ks,\n        charges,\n        independent_component_activity,\n    ) = _prepare_common_data(data)\n\n    total_concentration = np.vstack(\n        [\n            _titration_total_c(t, i)\n            for t, i in zip(data.potentiometry_options.titrations, idx_to_keep)\n        ]\n    )\n\n    original_log_beta = np.tile(original_log_beta, (total_concentration.shape[0], 1))\n    original_log_ks = np.tile(original_log_ks, (total_concentration.shape[0], 1))\n\n    outer_fixed_point_params = _assemble_outer_fixed_point_params(\n        data, charges, independent_component_activity\n    )\n\n    _initial_guess, *_ = solve_equilibrium_equations(\n        stoichiometry=stoichiometry,\n        solid_stoichiometry=solid_stoichiometry,\n        original_log_beta=original_log_beta,\n        original_log_ks=original_log_ks,\n        total_concentration=total_concentration,\n        outer_fiexd_point_params=outer_fixed_point_params,\n        initial_guess=None,\n        full=False,\n    )\n\n    if outer_fixed_point_params[\"ionic_strength_dependence\"] is True:\n        print(\n            \"Ionic strength dependence for potentiometry oprimization is not implemented yet.\"\n        )\n        outer_fixed_point_params[\"ionic_strength_dependence\"] = False\n\n    x, concs, return_extra = levenberg_marquardt(\n        np.fromiter(unravel(data.log_beta, beta_flags), dtype=float) * 2.303,\n        full_emf,\n        f_obj,\n        free_conc,\n        jacobian,\n        weights,\n        report=reporter,\n    )\n\n    b_error, cor_matrix, cov_matrix = fit_final_calcs(\n        return_extra[\"jacobian\"], return_extra[\"residuals\"], return_extra[\"weights\"]\n    )\n\n    return x, concs, b_error, cor_matrix, cov_matrix, return_extra\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.build_reduced_emf","title":"build_reduced_emf","text":"<pre><code>build_reduced_emf(emf, emf0, slope)\n</code></pre> <p>Build the reduced emf array from the emf, emf0, and slope values.</p> Parameters: <p>emf : numpy.ndarray     The emf values. emf0 : float     The standard emf value. slope : float     The slope.</p> Returns: <p>reduced_emf : numpy.ndarray     The reduced emf values.</p> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def build_reduced_emf(emf, emf0, slope):\n    \"\"\"\n    Build the reduced emf array from the emf, emf0, and slope values.\n\n    Parameters:\n    -------\n    emf : numpy.ndarray\n        The emf values.\n    emf0 : float\n        The standard emf value.\n    slope : float\n        The slope.\n\n    Returns:\n    -------\n    reduced_emf : numpy.ndarray\n        The reduced emf values.\n\n    \"\"\"\n    return (emf - emf0) / (slope / 2.303)\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.compute_weights","title":"compute_weights","text":"<pre><code>compute_weights(emf, v_add, e_sigma, v_sigma)\n</code></pre> <p>Compute the weights for the given emf, v_add, e_sigma, and v_sigma values.</p> Parameters: <p>emf : numpy.ndarray     The emf values. v_add : numpy.ndarray     The v_add values. e_sigma : numpy.ndarray     The e_sigma values. v_sigma : numpy.ndarray     The v_sigma values.</p> Returns: <p>weights : numpy.ndarray     The calculated weights.</p> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def compute_weights(emf, v_add, e_sigma, v_sigma):\n    \"\"\"\n    Compute the weights for the given emf, v_add, e_sigma, and v_sigma values.\n\n    Parameters:\n    -------\n    emf : numpy.ndarray\n        The emf values.\n    v_add : numpy.ndarray\n        The v_add values.\n    e_sigma : numpy.ndarray\n        The e_sigma values.\n    v_sigma : numpy.ndarray\n        The v_sigma values.\n\n    Returns:\n    -------\n    weights : numpy.ndarray\n        The calculated weights.\n\n    \"\"\"\n    der2 = np.gradient(emf, v_add) ** 2\n    return 1 / (der2 * v_sigma**2 + e_sigma**2)\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.hselect","title":"hselect","text":"<pre><code>hselect(array, hindices, slices)\n</code></pre> <p>Select columns that correspond to the electroactive species.</p> <p>Given the concentrations array, selects the columns that correspond to the electroactive species.</p> <p>Parameters:     array (:class:<code>numpy.ndarray</code>): The :term:<code>free concentrations array</code>     hindices (list): List of ints or list of lists of ints with the indices         of the electroactive species. Example: [[0,1],[1,2],[3,4],[4,5]].         hindices are applied along axis=0     slices (list of ints): Where to divide C. Example: [ 0, 5, 10, 15 ]         slices are applied along axis=1</p> <p>Returns:     The part of C which is electroactive</p> <p>slices = [0, 4, 7] hindices = [[0,1],[1,2],[3,4]] C = np.array([[ 0.255,  0.638,  0.898,  0.503,  0.418], ...               [ 0.383,  0.789,  0.731,  0.713,  0.629], ...               [ 0.698,  0.080,  0.597,  0.503,  0.456], ...               [ 0.658,  0.399,  0.332,  0.700,  0.294], ...               [ 0.534,  0.556,  0.762,  0.493,  0.510], ...               [ 0.637,  0.065,  0.638,  0.770,  0.879], ...               [ 0.598,  0.193,  0.912,  0.263,  0.118], ...               [ 0.456,  0.680,  0.049,  0.381,  0.872], ...               [ 0.418,  0.456,  0.430,  0.842,  0.172]]) hselect(C, hindices, slices) array([[0.255, 0.638], [0.383, 0.789], [0.698, 0.080], [0.658, 0.399],        [0.556, 0.762], [0.065, 0.638], [0.193, 0.912], [0.381, 0.872],        [0.842, 0.172]])</p> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def hselect(array, hindices, slices):\n    \"\"\"Select columns that correspond to the electroactive species.\n\n    Given the concentrations array, selects the columns that correspond\n    to the electroactive species.\n\n    Parameters:\n        array (:class:`numpy.ndarray`): The :term:`free concentrations array`\n        hindices (list): List of ints or list of lists of ints with the indices\n            of the electroactive species. Example: [[0,1],[1,2],[3,4],[4,5]].\n            hindices are applied along axis=0\n        slices (list of ints): Where to divide C. Example: [ 0, 5, 10, 15 ]\n            slices are applied along axis=1\n\n    Returns:\n        The part of C which is electroactive\n\n    &gt;&gt;&gt; slices = [0, 4, 7]\n    &gt;&gt;&gt; hindices = [[0,1],[1,2],[3,4]]\n    &gt;&gt;&gt; C = np.array([[ 0.255,  0.638,  0.898,  0.503,  0.418],\n    ...               [ 0.383,  0.789,  0.731,  0.713,  0.629],\n    ...               [ 0.698,  0.080,  0.597,  0.503,  0.456],\n    ...               [ 0.658,  0.399,  0.332,  0.700,  0.294],\n    ...               [ 0.534,  0.556,  0.762,  0.493,  0.510],\n    ...               [ 0.637,  0.065,  0.638,  0.770,  0.879],\n    ...               [ 0.598,  0.193,  0.912,  0.263,  0.118],\n    ...               [ 0.456,  0.680,  0.049,  0.381,  0.872],\n    ...               [ 0.418,  0.456,  0.430,  0.842,  0.172]])\n    &gt;&gt;&gt; hselect(C, hindices, slices)\n    array([[0.255, 0.638], [0.383, 0.789], [0.698, 0.080], [0.658, 0.399],\n           [0.556, 0.762], [0.065, 0.638], [0.193, 0.912], [0.381, 0.872],\n           [0.842, 0.172]])\n    \"\"\"\n    if slices is None and isinstance(int, hindices):\n        return array[:, hindices, ...]\n\n    if len(hindices) != len(slices):\n        raise TypeError(\"hindices and slices have wrong size\")\n    # libaux.assert_array_dim(2, array)\n\n    # slices \u2192 [ 0, 5, 10, 15 ]\n    #          0\u21924 5\u21929  10\u219214  15\u2192end\n    # hindices \u2192 [[0,1],[1,2],[3,4],[4,5]]\n    # 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17\n    # -------------  ------------- -------------- --------\n    # 0  0  0  0  0  1  1  1  1  1  3  3  3  3  3  4  4  4\n    # 1  1  1  1  1  2  2  2  2  2  4  4  4  4  4  5  5  5\n\n    num_points = array.shape[0]\n    nslices = (b - a for a, b in zip(slices, slices[1:] + [array.shape[0]]))\n    # y = np.array(sum([n*h for n, h in zip(nslices, hindices)], []))\n    y = np.vstack([np.tile(np.array(h), (n, 1)) for h, n in zip(hindices, nslices)])\n    return np.squeeze(array[np.arange(num_points), y.T, ...].T)\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.unravel","title":"unravel","text":"<pre><code>unravel(x, flags)\n</code></pre> <p>Unravel data according to flags provided.</p> <p>This routine takes an array of data and an array of flags of the same length and returns another array with only the independet variables.</p> <p>Parameters:     x (iterable): the original data values     flags (iterable): the flags indicating how to update x.         Values must int. Accepted values are</p> <pre><code>    * 0: value is to be kept constant\n    * 1: value is to be refined and the corresponding value from x\n      will be substituted by the corresponding value from y.\n    * &gt;2: value is restrained. All places with the same number are\n      refined together and the ratio between them is maintained.\n</code></pre> <p>Returns:     generator: Values of x processed according to flags.</p> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def unravel(x, flags):\n    \"\"\"Unravel data according to flags provided.\n\n    This routine takes an array of data and an array of flags of the same\n    length and returns another array with only the independet variables.\n\n    Parameters:\n        x (iterable): the original data values\n        flags (iterable): the flags indicating how to update x.\n            Values must int. Accepted values are\n\n            * 0: value is to be kept constant\n            * 1: value is to be refined and the corresponding value from x\n              will be substituted by the corresponding value from y.\n            * &gt;2: value is restrained. All places with the same number are\n              refined together and the ratio between them is maintained.\n\n    Returns:\n        generator: Values of **x** processed according to **flags**.\n    \"\"\"\n    constr_list = []\n    for i, f in zip(x, flags):\n        if f == 1:\n            yield i\n        if f &gt; 1:\n            if f not in constr_list:\n                yield i\n                constr_list.append(f)\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.ravel","title":"ravel","text":"<pre><code>ravel(x, y, flags)\n</code></pre> <p>Update values from one iterable with other iterable according to flags.</p> <p>This function does the opposite action than :func:<code>unravel</code>.</p> <p>Parameters:     x (iterable): the original array values     y (iterable): the updated values to be plugged into x.     flags (sequence): flags indicating how to update x with y. Accepted         values are:</p> <pre><code>    * 0: value is to be kept constant\n    * 1: value is to be refined and the corresponding value from x\n      will be substituted by the corresponding value from y.\n    * &gt;2: value is restrained. All places with the same number are\n      refined together and the ratio between them is maintained.\n</code></pre> <p>Yields:     float: Raveled values.</p> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def ravel(x, y, flags):\n    \"\"\"Update values from one iterable with other iterable according to flags.\n\n    This function does the opposite action than :func:`unravel`.\n\n    Parameters:\n        x (iterable): the original array values\n        y (iterable): the updated values to be plugged into *x*.\n        flags (sequence): flags indicating how to update *x* with *y*. Accepted\n            values are:\n\n            * 0: value is to be kept constant\n            * 1: value is to be refined and the corresponding value from x\n              will be substituted by the corresponding value from y.\n            * &gt;2: value is restrained. All places with the same number are\n              refined together and the ratio between them is maintained.\n\n    Yields:\n        float: Raveled values.\n    \"\"\"\n    # indices of the reference parameter for constraining\n    ref_index = {i: flags.index(i) for i in range(2, 1 + max(flags))}\n    ref_val = {}\n\n    ity = iter(y)\n    for i, f in enumerate(flags):\n        if f == 1:  # refinable: return new value\n            yield next(ity)\n        elif f == 0:  # constant: return old value\n            yield x[i]\n        else:  # constrained: return or compute\n            if i == ref_index[f]:\n                val = next(ity)  # reference value: return new value\n                ref_val[f] = val  # and store ref value\n                yield val\n            else:  # other: compute proportional value\n                yield x[i] * ref_val[f] / x[ref_index[f]]\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.covariance_fun","title":"covariance_fun","text":"<pre><code>covariance_fun(J, W, F)\n</code></pre> <p>Compute covariance matrix.</p> <p>Returns the covariance matrix :math:<code>CV = inv(J'.W.J)*MSE</code> Where MSE is mean-square error :math:<code>MSE = (R'*R)/(N-p)</code> where R are the residuals, N is the number of observations and p is the number of coefficients estimated</p> <p>Parameters:     J (:class:<code>numpy.ndarray</code>): the jacobian     W (:class:<code>numpy.ndarray</code>): the weights matrix     F (:class:<code>numpy.ndarray</code>): the residuals Returns:     :class:<code>numpy.ndarray</code>: an (p, p)-sized array representing         the covariance matrix.</p> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def covariance_fun(J, W, F):\n    \"\"\"Compute covariance matrix.\n\n    Returns the covariance matrix :math:`CV = inv(J'.W.J)*MSE`\n    Where MSE is mean-square error :math:`MSE = (R'*R)/(N-p)`\n    where *R* are the residuals, *N* is the number of observations and\n    *p* is the number of coefficients estimated\n\n    Parameters:\n        J (:class:`numpy.ndarray`): the jacobian\n        W (:class:`numpy.ndarray`): the weights matrix\n        F (:class:`numpy.ndarray`): the residuals\n    Returns:\n        :class:`numpy.ndarray`: an (*p*, *p*)-sized array representing\n            the covariance matrix.\n    \"\"\"\n    mse = np.sum(F * np.diag(W) * F) / (len(F) - J.shape[1])\n    temp = np.linalg.inv(np.dot(np.dot(J.T, W), J))\n    return temp * mse\n</code></pre>"},{"location":"reference/libeq/optimizers/potentiometry/#libeq.optimizers.potentiometry.fit_final_calcs","title":"fit_final_calcs","text":"<pre><code>fit_final_calcs(jacobian, resids, weights)\n</code></pre> <p>Perform final calculations common to some routines.</p> <p>Parameters:     jacobian (:class:<code>numpy.array</code>): the jacobian     resids (:class:<code>numpy.array</code>): the residuals     weights (:class:<code>numpy.array</code>): the weights Returns:     * the error in beta     * the correlation matrix     * the covariance matrix</p> Source code in <code>src/libeq/optimizers/potentiometry.py</code> <pre><code>def fit_final_calcs(jacobian, resids, weights):\n    \"\"\"Perform final calculations common to some routines.\n\n    Parameters:\n        jacobian (:class:`numpy.array`): the jacobian\n        resids (:class:`numpy.array`): the residuals\n        weights (:class:`numpy.array`): the weights\n    Returns:\n        * the error in beta\n        * the correlation matrix\n        * the covariance matrix\n    \"\"\"\n    covariance = covariance_fun(jacobian, weights, resids)\n    cov_diag = np.diag(covariance)\n    error_B = np.sqrt(cov_diag) / np.log(10)\n    lenD = len(cov_diag)\n    correlation = covariance / np.sqrt(\n        np.dot(cov_diag.reshape((lenD, 1)), cov_diag.reshape((1, lenD)))\n    )\n    return error_B, correlation, covariance\n</code></pre>"},{"location":"reference/libeq/outer_fixed_point/","title":"outer_fixed_point","text":""},{"location":"reference/libeq/outer_fixed_point/wrappers/","title":"wrappers","text":""},{"location":"reference/libeq/outer_fixed_point/wrappers/#libeq.outer_fixed_point.wrappers.outer_fixed_point","title":"outer_fixed_point","text":"<pre><code>outer_fixed_point(\n    *,\n    ionic_strength_dependence: bool = False,\n    charges: NDArray | None = None,\n    reference_ionic_str_species: NDArray | None = None,\n    reference_ionic_str_solids: NDArray | None = None,\n    dbh_values: dict[str, dict[str, NDArray]] | None = None,\n    independent_component_activity: NDArray | None = None\n)\n</code></pre> <p>Decorator for implementing the outer fixed point iteration method as developed described by Carrayrou, et al. <sup>1</sup>.</p> <p>Given a function capable of solving the equilibrium equations for a given set of species concentrations, the outer fixed point method fixes the activity coefficients and solve the equilibrium equations. After convergence is achieved for the species concentrations, the activity coefficients are updated and the process is repeated. If the activity coefficient do not change significantly between iterations, the process is considered converged and both species concentrations and activity coefficients are returned.</p> <ol> <li> <p>Carrayrou, et al.: AIChE Journal 2022, 68, e17391\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>ionic_strength_dependence</code> <code>bool</code> <p>Flag indicating whether to consider ionic strength dependence, by default False.</p> <code>False</code> <code>charges</code> <code>ndarray or None</code> <p>Array of charges for each species, by default None.</p> <code>None</code> <code>reference_ionic_str_species</code> <code>ndarray or None</code> <p>Array of reference ionic strength for each species, by default None.</p> <code>None</code> <code>reference_ionic_str_solids</code> <code>ndarray or None</code> <p>Array of reference ionic strength for each solid, by default None.</p> <code>None</code> <code>dbh_values</code> <code>dict[str, dict[str, ndarray]] or None</code> <p>Dictionary containing the debye huckel parameters used for the species and solids, by default None.</p> <code>None</code> <code>independent_component_activity</code> <code>ndarray or None</code> <p>Array of independent component activities, by default None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>decorator</code> <code>function</code> <p>The outer fixed point decorator.</p> <p>Examples:</p> <p>Apply the outer_fixed_point decorator to a function:</p> <pre><code>@outer_fixed_point(\n    ionic_strength_dependence=True,\n    charges=[1,0,-1],\n    ref_ionic_strength_species=[0.1,0.1,0.1],\n    ref_ionic_strength_solids=[0.1,0.1,0.1],\n    dbh_values={\"species\": {...}, \"solids\": {...}\n    independent_component_activity=None\n    )\ndef equilibrium_equations(concentration, log_beta, log_ks):\n    # implementation of equilibrium equations\n    pass\n</code></pre> <p>The resulting function can then be called with to compute the species concentrations at equilibrium:</p> <pre><code>result, final_log_beta, final_log_ks = equilibrium_equations(concentration, log_beta, log_ks)\n</code></pre> <p>If ionic_strength_dependence is set to True, the decorator will perform the outer fixed point iteration method, otherwise it will return the result of the decorated function.</p> Source code in <code>src/libeq/outer_fixed_point/wrappers.py</code> <pre><code>def outer_fixed_point(\n    *,\n    ionic_strength_dependence: bool = False,\n    charges: NDArray | None = None,\n    reference_ionic_str_species: NDArray | None = None,\n    reference_ionic_str_solids: NDArray | None = None,\n    dbh_values: dict[str, dict[str, NDArray]] | None = None,\n    independent_component_activity: NDArray | None = None,\n):\n    \"\"\"\n    Decorator for implementing the outer fixed point iteration method as developed described by Carrayrou, *et al.* [^1].\n\n    Given a function capable of solving the equilibrium equations for a given set of species concentrations,\n    the outer fixed point method fixes the activity coefficients and solve the equilibrium equations.\n    After convergence is achieved for the species concentrations, the activity coefficients are updated and the process is repeated.\n    If the activity coefficient do not change significantly between iterations, the process is considered converged and both species\n    concentrations and activity coefficients are returned.\n\n    [^1]: Carrayrou, *et al.*: *AIChE Journal* 2022, **68**, e17391\n\n    Parameters\n    ----------\n    ionic_strength_dependence : bool, optional\n        Flag indicating whether to consider ionic strength dependence, by default False.\n    charges : numpy.ndarray or None, optional\n        Array of charges for each species, by default None.\n    reference_ionic_str_species : numpy.ndarray or None, optional\n        Array of reference ionic strength for each species, by default None.\n    reference_ionic_str_solids : numpy.ndarray or None, optional\n        Array of reference ionic strength for each solid, by default None.\n    dbh_values : dict[str, dict[str, numpy.ndarray]] or None, optional\n        Dictionary containing the debye huckel parameters used for the species and solids, by default None.\n    independent_component_activity : numpy.ndarray or None, optional\n        Array of independent component activities, by default None.\n\n    Returns\n    -------\n    decorator : function\n        The outer fixed point decorator.\n\n    Examples\n    --------\n    Apply the outer_fixed_point decorator to a function:\n\n    ```python\n    @outer_fixed_point(\n        ionic_strength_dependence=True,\n        charges=[1,0,-1],\n        ref_ionic_strength_species=[0.1,0.1,0.1],\n        ref_ionic_strength_solids=[0.1,0.1,0.1],\n        dbh_values={\"species\": {...}, \"solids\": {...}\n        independent_component_activity=None\n        )\n    def equilibrium_equations(concentration, log_beta, log_ks):\n        # implementation of equilibrium equations\n        pass\n    ```\n\n    The resulting function can then be called with to compute the species concentrations at equilibrium:\n\n    ```python\n    result, final_log_beta, final_log_ks = equilibrium_equations(concentration, log_beta, log_ks)\n    ```\n\n    If ionic_strength_dependence is set to True, the decorator will perform the outer fixed point iteration method,\n    otherwise it will return the result of the decorated function.\n\n    \"\"\"\n\n    def decorator(func):\n        def unwrapped(concentration, **kwargs):\n            log_beta = kwargs.pop(\"log_beta\")\n            log_ks = kwargs.pop(\"log_ks\")\n            return (\n                func(concentration, log_beta=log_beta, log_ks=log_ks, **kwargs),\n                log_beta,\n                log_ks,\n            )\n\n        def wrapper(\n            concentration,\n            **kwargs,\n        ):\n            if independent_component_activity is not None:\n                transposed_activity = independent_component_activity[:, np.newaxis]\n            else:\n                transposed_activity = None\n\n            log_beta = kwargs.pop(\"log_beta\")\n            log_ks = kwargs.pop(\"log_ks\")\n            og_log_beta = log_beta.copy()\n            og_log_ks = log_ks.copy()\n            stoichiometry = kwargs[\"stoichiometry\"]\n\n            n_components = stoichiometry.shape[0]\n            n_species = stoichiometry.shape[1]\n\n            concentrations = species_concentration(\n                concentration, log_beta, stoichiometry, full=True\n            )\n            ionic = _ionic_fn(\n                _select_species_concentration(concentrations, n_components, n_species),\n                charges,\n                independent_component_activity=transposed_activity,\n            )\n            log_beta = _update_formation_constants(\n                og_log_beta,\n                ionic,\n                reference_ionic_str_species,\n                dbh_values[\"species\"],\n            )\n            log_ks = _update_solubility_products(\n                og_log_ks, ionic, reference_ionic_str_solids, dbh_values[\"solids\"]\n            )\n\n            result = concentration\n            iterations = 0\n            while True:\n                iterations += 1\n                # Call the decorated function\n                result = func(\n                    result,\n                    log_beta=log_beta,\n                    log_ks=log_ks,\n                    **kwargs,\n                )\n\n                # Code to be executed after the decorated function\n                concentrations = species_concentration(\n                    result, log_beta, stoichiometry, full=True\n                )\n                ionic = _ionic_fn(\n                    _select_species_concentration(\n                        concentrations, n_components, n_species\n                    ),\n                    charges,\n                    independent_component_activity=transposed_activity,\n                )\n\n                old_log_beta = log_beta\n                old_log_ks = log_ks\n\n                log_beta = _update_formation_constants(\n                    og_log_beta,\n                    ionic,\n                    reference_ionic_str_species,\n                    dbh_values[\"species\"],\n                )\n                log_ks = _update_solubility_products(\n                    og_log_ks, ionic, reference_ionic_str_solids, dbh_values[\"solids\"]\n                )\n\n                if _check_outer_point_convergence(\n                    log_beta, old_log_beta, log_ks, old_log_ks\n                ):\n                    # print(func.__name__)\n                    # print(f\"Outer converged in {iterations} iterations\")\n                    # print(\"------------------------\")\n                    break\n            return result, old_log_beta, old_log_ks\n\n        def _distribution_ionic(\n            concentration: NDArray,\n            charges: NDArray,\n            *,\n            independent_component_activity: NDArray,\n        ) -&gt; NDArray:\n            return _ionic(concentration, charges) + independent_component_activity\n\n        def _ionic(concentration: NDArray, charges: NDArray, **kwargs) -&gt; NDArray:\n            return 0.5 * (concentration * (charges**2)).sum(axis=1, keepdims=True)\n\n        if ionic_strength_dependence:\n            if independent_component_activity is None:\n                _ionic_fn = _ionic\n            else:\n                _ionic_fn = _distribution_ionic\n\n            return wrapper\n        else:\n            return unwrapped\n\n    return decorator\n</code></pre>"},{"location":"reference/libeq/parsers/","title":"parsers","text":""},{"location":"reference/libeq/parsers/bstac/","title":"bstac","text":""},{"location":"reference/libeq/parsers/bstac/#libeq.parsers.bstac.parse_titration","title":"parse_titration","text":"<pre><code>parse_titration(lines, jw, nc) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>src/libeq/parsers/bstac.py</code> <pre><code>def parse_titration(lines, jw, nc) -&gt; list[dict[str, Any]]:\n    tot_length = len(lines)\n    sections = [\n        (lambda line: line.strip(), 1, \"titration_name\"),  # NAMET\n        (\n            lambda line: [int(part) for part in line.split()],\n            1,\n            \"titration_comp_settings\",\n        ),  # JP,NCET\n        (\n            lambda line: [\n                float(part) if i != 2 else int(part)\n                for i, part in enumerate(line.split())\n            ],\n            \"NC\",\n            \"components_concentrations\",\n        ),  # CO,CTT,LOK\n        (\n            lambda line: [float(part) for _, part in enumerate(line.split())],\n            1,\n            \"background_params\",\n        ),  # COI,CTI,IREFT\n        (\n            lambda line: [float(part) for _, part in enumerate(line.split())],\n            1,\n            \"v_params\",\n        ),  # VO,SIGMAV\n        (\n            lambda line: [\n                float(part) if i &lt; 5 else int(part)\n                for i, part in enumerate(line.split())\n            ],\n            1,\n            \"potential_params\",\n        ),  # E0,SIGMAE,JA,JB,SLOPE,LOK1,LOK2,LOK3,LOK4\n        (\n            lambda line: [\n                float(part) if i != 3 else int(part)\n                for i, part in enumerate(\n                    map(lambda x: x.replace(\"(\", \"\").replace(\")\", \"\"), line.split())\n                )\n            ],\n            \"until_end\",\n            \"titration_values\",\n        ),  # V,E,(SIGMA),IND\n    ]\n    line_counter = 0\n    titrations = []\n    while True:\n        titration = {}\n        for process_func, repeat, name in sections:\n            if isinstance(repeat, int):\n                for _ in range(repeat):\n                    titration[name] = process_func(lines[line_counter])\n                    line_counter += 1\n            elif repeat == \"NC\":\n                for _ in range(nc):\n                    parsed_line = process_func(lines[line_counter])\n                    parsed_line = {\n                        k: v\n                        for k, v in zip(\n                            [\"C0\", \"CTT\", \"LOK\"],\n                            parsed_line,\n                        )\n                    }\n                    titration.setdefault(name, []).append(parsed_line)\n                    line_counter += 1\n\n            elif repeat == \"until_end\":\n                while True:\n                    parsed_line = process_func(lines[line_counter])\n                    titration.setdefault(\"volume\", []).append(parsed_line[0])\n                    titration.setdefault(\"potential\", []).append(parsed_line[1])\n                    if jw == 2:\n                        titration.setdefault(\"sigma\", []).append(parsed_line[2])\n                    line_counter += 1\n                    if parsed_line[-1] == 1:\n                        break\n\n        titrations.append(titration)\n        if line_counter == tot_length:\n            break\n\n    return titrations\n</code></pre>"},{"location":"reference/libeq/parsers/bstac/#libeq.parsers.bstac.parse_model","title":"parse_model","text":"<pre><code>parse_model(lines, icd, nc) -&gt; list[dict[str, Any]]\n</code></pre> Source code in <code>src/libeq/parsers/bstac.py</code> <pre><code>def parse_model(lines, icd, nc) -&gt; list[dict[str, Any]]:\n    species = []\n    sections = [\n        lambda line: [\n            int(part) if i &gt; 2 else float(part)\n            for i, part in enumerate(\n                map(lambda x: x.replace(\"(\", \"\").replace(\")\", \"\"), line.split())\n            )\n        ],  # BLOG,IX(NC times),KEY,NKA,IKA(NKA times) (ICD=0)\n        lambda line: [\n            int(part) if i &gt; 4 else float(part)\n            for i, part in enumerate(\n                map(lambda x: x.replace(\"(\", \"\").replace(\")\", \"\"), line.split())\n            )\n        ],\n        # BLOG,(IB),C,D,E,IX(1...NC),KEY,KEYC,KEYD,KEYE,NKA,IKA(1...NKA) (ICD=1/2)\n    ]\n\n    if icd == 0:\n        process_func = sections[1]\n        model_columns = (\n            [\n                \"BLOG\",\n            ]\n            + [f\"IX{i}\" for i in range(1, nc + 1)]\n            + [\n                \"KEY\",\n                \"NKA\",\n            ]\n            + [f\"IKA{i}\" for i in range(1, 10)]\n        )\n    else:\n        process_func = sections[0]\n        model_columns = (\n            [\n                \"BLOG\",\n                \"IB\",\n                \"C\",\n                \"D\",\n                \"E\",\n            ]\n            + [f\"IX{i}\" for i in range(1, nc + 1)]\n            + [\n                \"KEY\",\n                \"KEYC\",\n                \"KEYD\",\n                \"KEYE\",\n                \"NKA\",\n            ]\n            + [f\"IKA{i}\" for i in range(1, 10)]\n        )\n\n    for line in lines:\n        parsed_line = process_func(line)\n        parsed_line = {\n            k: v\n            for k, v in zip(\n                model_columns,\n                parsed_line,\n            )\n        }\n        species.append(parsed_line)\n\n    return species\n</code></pre>"},{"location":"reference/libeq/parsers/bstac/#libeq.parsers.bstac.parse_BSTAC_file","title":"parse_BSTAC_file","text":"<pre><code>parse_BSTAC_file(lines)\n</code></pre> Source code in <code>src/libeq/parsers/bstac.py</code> <pre><code>def parse_BSTAC_file(lines):\n    # Define the list of tuples\n    sections = [\n        (lambda line: line.strip(), 1, \"file_name\"),  # TITLE\n        (\n            lambda line: [int(part) for part in line.split()],\n            1,\n            [\"MAXIT\", \"NC\", \"NS\", \"MODE\", \"ICD\", \"WESP\", \"SHLIM\"],\n        ),  # MAXIT,NC,NS,MODE,ICD,WESP,SHLIM\n        (lambda line: line.strip(), \"NC\", \"comp_name\"),  # COMP\n        (\n            lambda line: [float(part) for part in line.split()],\n            1,\n            [\"TEMP\", \"PHI\", \"PHF\"],\n        ),  # TEMP,PHI,PHF\n        (\n            lambda line: [\n                float(part) if i &lt; 9 else int(part)\n                for i, part in enumerate(line.split())\n            ],\n            \"ICD\",\n            [\"IREF\", \"AT\", \"BT\", \"c0\", \"c1\", \"d0\", \"d1\", \"e0\", \"e1\", \"KCD\"],\n        ),  # IREF,AT,BT,c0,c1,d0,d1,e0,e1,KCD(1...6)\n        (\n            lambda line: [float(part) for part in line.split()],\n            1,\n            \"charges\",\n        ),  # Z(1...NC)\n        (\n            parse_model,\n            \"NS\",\n            \"species\",\n        ),  # BLOG,(IB),C,D,E,IX(1...NC),KEY,KEYC,KEYD,KEYE,NKA,IKA(1...NKA)\n        (parse_titration, \"end_of_file\", \"titrations\"),\n    ]\n\n    result = {}\n    line_counter = 0\n\n    for process_func, repeat, name in sections:\n        if isinstance(repeat, int):\n            for _ in range(repeat):\n                if isinstance(name, str):\n                    result[name] = process_func(lines[line_counter])\n                elif isinstance(name, list):\n                    for field_name, data in zip(\n                        name, process_func(lines[line_counter])\n                    ):\n                        result[field_name] = data\n                line_counter += 1\n        elif repeat == \"NC\":\n            nc = result[\"NC\"]  # Get the value of NC from the data\n            for _ in range(nc):\n                result.setdefault(name, []).append(process_func(lines[line_counter]))\n                line_counter += 1\n        elif repeat == \"ICD\":\n            icd = result[\"ICD\"]  # Get the value of ICD from the data\n            if icd &gt; 0:\n                for field_name, data in zip(name, process_func(lines[line_counter])):\n                    result[field_name] = data\n                line_counter += 1\n            else:\n                for field_name, data in zip(name, process_func(lines[line_counter])):\n                    result[field_name] = None\n        elif repeat == \"NS\":\n            ns = result[\"NS\"]  # Get the value of NS from the data\n            parsed_section = process_func(\n                lines[line_counter : line_counter + ns], icd, nc\n            )\n            result[name] = parsed_section\n            line_counter += ns\n        elif repeat == \"end_of_file\":\n            parsed_section = process_func(lines[line_counter:], result[\"MODE\"], nc)\n            result[name] = parsed_section\n\n    return result\n</code></pre>"},{"location":"reference/libeq/solver/","title":"solver","text":""},{"location":"reference/libeq/solver/damping/","title":"damping","text":""},{"location":"reference/libeq/solver/damping/#libeq.solver.damping.pcf","title":"pcf","text":"<pre><code>pcf(\n    concentration,\n    *,\n    log_beta,\n    stoichiometry,\n    total_concentration,\n    max_iterations=1000,\n    tol=0.25,\n    **kwargs\n) -&gt; npt.NDArray\n</code></pre> <p>Solve the mass balance equations using the Positive Continious Fraction method  by Marinoni, et al. <sup>1</sup>.</p> \\[ \\left[X_{j}\\right]^{n+1}=\\theta_{j}^{n}\\left[X_{j}\\right]^{n}\\left(\\frac{S u m_{j}^{p r o d,n}}{S u m_{j}^{r e a c t,n}}\\right)^{1/a_{i0j}}+\\left(1-\\theta_{j}^{n}\\right)\\left[X_{j}\\right]^{n} \\] <ol> <li> <p>Carrayrou, et al.: AIChE Journal 2017, 63, 1246-1262\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>concentration</code> <code>ndarray</code> <p>The concentration array of shape (n, c), where n is the number of points c is the number of components.</p> required <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the equilibrium constants with shape (n, s), where s is the number of soluble species.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, s), where s is the number of soluble species.</p> required <code>total_concentration</code> <code>ndarray</code> <p>The total concentration vector with shape (n, c), where n is the number of points c is the number of components..</p> required <code>max_iterations</code> <code>int</code> <p>The maximum number of iterations (default is 1000).</p> <code>1000</code> <code>tol</code> <code>float</code> <p>The tolerance for convergence criteria (default is 2.5e-1).</p> <code>0.25</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>c_spec</code> <code>ndarray</code> <p>The solution to the mass balance equations.</p> Source code in <code>src/libeq/solver/damping.py</code> <pre><code>def pcf(\n    concentration,\n    *,\n    log_beta,\n    stoichiometry,\n    total_concentration,\n    max_iterations=1000,\n    tol=2.5e-1,\n    **kwargs,\n) -&gt; npt.NDArray:\n    r\"\"\"\n    Solve the mass balance equations using the Positive Continious Fraction method  by Marinoni, *et al.* [^1].\n\n    $$\n    \\left[X_{j}\\right]^{n+1}=\\theta_{j}^{n}\\left[X_{j}\\right]^{n}\\left(\\frac{S u m_{j}^{p r o d,n}}{S u m_{j}^{r e a c t,n}}\\right)^{1/a_{i0j}}+\\left(1-\\theta_{j}^{n}\\right)\\left[X_{j}\\right]^{n}\n    $$\n\n    [^1]: Carrayrou, *et al.*: *AIChE Journal* 2017, **63**, 1246-1262\n\n    Parameters\n    ----------\n    concentration : numpy.ndarray\n        The concentration array of shape (n, c), where n is the number of points c is the number of components.\n    log_beta : numpy.ndarray\n        The logarithm of the equilibrium constants with shape (n, s), where s is the number of soluble species.\n    stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, s), where s is the number of soluble species.\n    total_concentration : numpy.ndarray\n        The total concentration vector with shape (n, c), where n is the number of points c is the number of components..\n    max_iterations : int, optional\n        The maximum number of iterations (default is 1000).\n    tol : float, optional\n        The tolerance for convergence criteria (default is 2.5e-1).\n    **kwargs : dict\n        Additional keyword arguments.\n\n    Returns\n    -------\n    c_spec : numpy.ndarray\n        The solution to the mass balance equations.\n    \"\"\"\n    nc = stoichiometry.shape[0]\n\n    coeff = np.array([0 for _ in range(nc)])\n    exponent = 1 / np.max(\n        np.where(stoichiometry == 0, 1, np.abs(stoichiometry)), axis=1\n    )\n    full_stoichiometry = np.concatenate((np.eye(nc), stoichiometry), axis=1)\n\n    pstoich, nstoich = _pos_neg_stoich(full_stoichiometry)\n\n    iteration = 0\n    while True:\n        c_spec = species_concentration(\n            concentration,\n            log_beta,\n            stoichiometry,\n            full=True,\n        )\n\n        sum_reac, sum_prod = _sumps(c_spec, total_concentration, pstoich, nstoich)\n\n        conv_criteria = np.abs((sum_reac - sum_prod) / (sum_reac + sum_prod))\n\n        if np.all(conv_criteria &lt;= tol) or iteration &gt;= max_iterations:\n            return c_spec[:, :nc]\n\n        ratio = sum_prod / sum_reac\n        new_coeff = 0.9 - np.where(ratio &lt; 1.0, ratio, 1 / ratio) * 0.8\n\n        if iteration == 0:\n            coeff = new_coeff\n        coeff = np.where(new_coeff &gt; coeff, new_coeff, coeff)\n\n        concentration *= coeff * ratio ** (exponent) + (1 - coeff)\n\n        iteration += 1\n</code></pre>"},{"location":"reference/libeq/solver/nr/","title":"nr","text":""},{"location":"reference/libeq/solver/nr/#libeq.solver.nr.newton_raphson","title":"newton_raphson","text":"<pre><code>newton_raphson(\n    x0: npt.NDArray,\n    *,\n    log_beta: npt.NDArray,\n    log_ks: npt.NDArray,\n    stoichiometry: npt.NDArray,\n    solid_stoichiometry: npt.NDArray,\n    total_concentration: npt.NDArray,\n    solids_idx: List[int] = [],\n    max_iterations: int = 1000,\n    threshold: float = 1e-10,\n    damping: bool = False,\n    forcer: bool = False,\n    scaling: bool = False,\n    step_limiter: bool = True,\n    zero_offdiag: bool = False,\n    debug: bool = False,\n    panic: bool = True,\n    **kwargs: Dict[str, Any]\n) -&gt; npt.NDArray\n</code></pre> <p>Solve the set of equations \\(J \\cdot \\delta c = -F\\) using Newton-Raphson's method.</p> <p>Given an initial guess x0 and the parameters of the titration, this function uses the Newton-Raphson method to solve the free concentrations.  It includes several convergence tecniques such as scaling, damping and step limiting. For the original source of damping and scaling see De Robertis, et al., <sup>1</sup> and also Del Piero, et al. <sup>2</sup>.</p> <p>Warning</p> <p>This function is the very core of the program. Do not change the default parameters unless you know what you are doing.</p> <ol> <li> <p>De Robertis, et al.: Analytica Chimica Acta 1986, 191, 385-398\u00a0\u21a9</p> </li> <li> <p>Del Piero, et al.: Annali di Chimica 2006, 96\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>ndarray</code> <p>The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of precipitates.</p> required <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the equilibrium constants with shape (n, s), where s is the number of soluble species.</p> required <code>log_ks</code> <code>ndarray</code> <p>The logarithm of the solubility products with shape (n, p), where p is the number of solid species.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, s), where s is the number of soluble species.</p> required <code>solid_stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, p), where s is the number of precipitable species.</p> required <code>total_concentration</code> <code>ndarray</code> <p>The total concentration vector with shape (n, c), where n is the number of points c is the number of components..</p> required <code>solids_idx</code> <code>List[int]</code> <p>Indices of solid species to compute.</p> <code>[]</code> <code>max_iterations</code> <code>int</code> <p>Maximum number of iterations.</p> <code>1000</code> <code>threshold</code> <code>float</code> <p>Convergence threshold.</p> <code>1e-10</code> <code>damping</code> <code>bool</code> <p>Whether to apply damping.</p> <code>False</code> <code>forcer</code> <code>bool</code> <p>Whether to use a line search algorithm.</p> <code>False</code> <code>scaling</code> <code>bool</code> <p>Whether to apply scaling to the Jacobian matrix.</p> <code>False</code> <code>step_limiter</code> <code>bool</code> <p>Whether to limit the step size.</p> <code>True</code> <code>zero_offdiag</code> <code>bool</code> <p>Whether to zero out off-diagonal elements of the Jacobian matrix.</p> <code>False</code> <code>debug</code> <code>bool</code> <p>Whether to print debug information.</p> <code>False</code> <code>panic</code> <code>bool</code> <p>Whether to save intermediate results in case of failure.</p> <code>True</code> <code>**kwargs</code> <code>Dict[str, Any]</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>x</code> <code>ndarray</code> <p>Array of shape (n, c+p) of final concentrations of all components in the system.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input is incorrect.</p> <code>FailedCalculateConcentrations</code> <p>If the Jacobian or residuals cannot be calculated.</p> <code>TooManyIterations</code> <p>If too many iterations are performed without convergence.</p> Source code in <code>src/libeq/solver/nr.py</code> <pre><code>def newton_raphson(\n    x0: npt.NDArray,\n    *,\n    log_beta: npt.NDArray,\n    log_ks: npt.NDArray,\n    stoichiometry: npt.NDArray,\n    solid_stoichiometry: npt.NDArray,\n    total_concentration: npt.NDArray,\n    solids_idx: List[int] = [],\n    max_iterations: int = 1000,\n    threshold: float = 1e-10,\n    damping: bool = False,\n    forcer: bool = False,\n    scaling: bool = False,\n    step_limiter: bool = True,\n    zero_offdiag: bool = False,\n    debug: bool = False,\n    panic: bool = True,\n    **kwargs: Dict[str, Any],\n) -&gt; npt.NDArray:\n    r\"\"\"\n    Solve the set of equations $J \\cdot \\delta c = -F$ using Newton-Raphson's method.\n\n    Given an initial guess **x0** and the parameters of the titration, this\n    function uses the Newton-Raphson method to solve the free\n    concentrations.  It includes several\n    convergence tecniques such as scaling, damping and step limiting. For the\n    original source of damping and scaling see De Robertis, *et al.*,\n    [^1] and also Del Piero, *et al.* [^2].\n\n\n    [^1]: De Robertis, *et al.*: *Analytica Chimica Acta* 1986, **191**, 385-398\n    [^2]: Del Piero, *et al.*: *Annali di Chimica* 2006, 96\n\n    !!! warning\n\n        This function is the very core of the program. Do not change\n        the default parameters unless you know what you are doing.\n\n    Parameters\n    ----------\n    x0 : numpy.ndarray\n        The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of precipitates.\n    log_beta : numpy.ndarray\n        The logarithm of the equilibrium constants with shape (n, s), where s is the number of soluble species.\n    log_ks : numpy.ndarray\n        The logarithm of the solubility products with shape (n, p), where p is the number of solid species.\n    stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, s), where s is the number of soluble species.\n    solid_stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, p), where s is the number of precipitable species.\n    total_concentration : numpy.ndarray\n        The total concentration vector with shape (n, c), where n is the number of points c is the number of components..\n    solids_idx : List[int]\n        Indices of solid species to compute.\n    max_iterations : int\n        Maximum number of iterations.\n    threshold : float\n        Convergence threshold.\n    damping : bool\n        Whether to apply damping.\n    forcer : bool\n        Whether to use a line search algorithm.\n    scaling : bool\n        Whether to apply scaling to the Jacobian matrix.\n    step_limiter : bool\n        Whether to limit the step size.\n    zero_offdiag : bool\n        Whether to zero out off-diagonal elements of the Jacobian matrix.\n    debug : bool\n        Whether to print debug information.\n    panic : bool\n        Whether to save intermediate results in case of failure.\n    **kwargs : Dict[str, Any]\n        Additional keyword arguments.\n\n    Returns\n    -------\n    x : numpy.ndarray\n        Array of shape (n, c+p) of final concentrations of all components in the system.\n\n    Raises\n    ------\n    ValueError\n        If the input is incorrect.\n    FailedCalculateConcentrations\n        If the Jacobian or residuals cannot be calculated.\n    TooManyIterations\n        If too many iterations are performed without convergence.\n    \"\"\"\n\n    def _panic_save():\n        if panic:\n            np.savez_compressed(\n                \"consol_panic.npz\",\n                free_concentration=x0,\n                log_beta=log_beta,\n                stoichiometry=stoichiometry,\n                analytc=total_concentration,\n            )\n\n    if zero_offdiag and scaling:\n        raise ValueError(\n            \"Options scaling and zero_offdiag are not compatible with each other\"\n        )\n\n    if \"do_iterations\" in kwargs:\n        do_iterations = kwargs[\"do_iterations\"]\n        if not isinstance(do_iterations, int):\n            raise TypeError(\"do_iteration must be a positive int.\")\n        if do_iterations &lt; 1:\n            raise ValueError(\"do_iteration must be a positive int.\")\n    else:\n        do_iterations = None\n\n    n_components = stoichiometry.shape[0]\n    n_species = stoichiometry.shape[1]\n    n_solids = solid_stoichiometry.shape[1]\n\n    solids_to_remove = np.array(\n        list(set(range(n_components, n_components + n_solids)) - set(solids_idx)),\n        dtype=int,\n    )\n\n    # copy x0 so that it is not modified outside this function.\n    x = np.delete(np.copy(x0), solids_to_remove, axis=-1)\n    solid_stoichiometry = np.delete(\n        np.copy(solid_stoichiometry), solids_to_remove - n_components, axis=-1\n    )\n    log_ks = np.delete(np.copy(log_ks), solids_to_remove - n_components, axis=-1)\n\n    # ------ check input --------\n    # libaux.assert_array_dim(2, x0)\n    x, total_concentration = np.atleast_2d(x, total_concentration)\n\n    # ------ main loop ----------\n    for iterations in range(max_iterations):\n        c0 = species_concentration(x, log_beta, stoichiometry, full=True)\n\n        _c = c0\n\n        F = fobj(\n            _c,\n            log_ks,\n            stoichiometry,\n            solid_stoichiometry,\n            total_concentration,\n        )\n        J = jacobian(_c, stoichiometry, solid_stoichiometry)\n\n        if np.any(np.isnan(J)):\n            _panic_save()\n            msg2 = f\"could not calculate jacobian (iteration {iterations})\"\n            raise FailedCalculateConcentrations(msg2, x)\n        if np.any(np.isnan(F)):\n            msg2 = f\"could not calculate residuals (iteration {iterations})\"\n            raise FailedCalculateConcentrations(msg2, x)\n\n        # FIXME This should be deleted when debug is not necessary\n        # if not iterations % 50:\n        #     print('chisq(it:', iterations, 'n:', T.shape[0], ') = ',\n        #           np.sum(F**2), np.max(np.abs(F)))\n\n        if zero_offdiag:\n            J *= np.eye(n_species)  # zerom\n\n        if scaling:\n            d = DRScaling(J, F)\n            dx = np.linalg.solve(J, -F) / np.sqrt(d)\n        else:\n            dx = np.linalg.solve(J, -F)\n\n        if forcer:\n            step_length, _ = linesearch3(\n                x, dx, log_beta, stoichiometry, total_concentration\n            )\n            x += step_length[:, None] * dx\n        elif step_limiter:\n            x[:, :n_components] += (\n                limit_step(x[:, :n_components], dx[:, :n_components])\n                * x[:, :n_components]\n            )\n            x[:, n_components:] += dx[:, n_components:]\n        else:\n            x += dx * x\n\n        if (do_iterations and iterations + 1 &gt;= do_iterations) or np.all(\n            np.abs(F) &lt; threshold\n        ):\n            if solids_to_remove.size != 0:\n                x = np.insert(\n                    x, np.clip(solids_to_remove, a_min=0, a_max=x.shape[1]), 0, axis=1\n                )\n            return x\n\n        if damping:\n            x = pcf(x, log_beta, stoichiometry, total_concentration)\n\n    raise TooManyIterations(\"too many iterations\", x)\n</code></pre>"},{"location":"reference/libeq/solver/nr/#libeq.solver.nr.linesearch3","title":"linesearch3","text":"<pre><code>linesearch3(\n    x0: npt.NDArray,\n    dx: npt.NDArray,\n    log_beta: npt.NDArray,\n    stoichiometry: npt.NDArray,\n    T: npt.NDArray,\n    lmax=None,\n    g0=None,\n    g2=None,\n)\n</code></pre> <p>Three-point parabolic line search.</p> <p>This functions implements a 3-point linesearch in the Newton direction. This is a variation of the line search for 2 points<sup>1</sup>. The function to be minimized is the same though but the approach is different and it is adapted to the nature of the problem of concentration solving. We define a function \\((f=\\frac12F\\cdot F)\\) which is to be minimized. Then we define a parameter \\(\\lambda\\) that \\(0&lt;\\lambda&lt;1\\) which is the fraction of the Newton step and then another function g which is function of the fractional is defined so that: $$ g(\\lambda) = f(x_0 + \\lambda \\delta x) $$ We know that negative \\(x_0\\) values are forbidden, therefore \\(\\lambda\\) might limited to values lower than 1. The maximum value allowed for \\(\\lambda\\) is that that makes any concentration equal to 0, therefore \\((\\lambda_{max} = -x_0/\\delta\\) if \\(-x_0/\\delta&lt;1)\\)</p> <p>\\(g(\\lambda)\\) is modeled as a parabolic function for which we calculate the values for \\(\\lambda=0\\), \\(\\lambda= \\frac{1}{2}\\lambda_{max}\\) and \\(\\lambda=0.99\\lambda_{max}\\).</p> <ol> <li> <p>W. H. Press, S. A. Teukolksy, W. T. Vetterling, Brian P. Flannery,    Numerical Recipes in C. The Art of Scientific Computing, Second Edition    1997, pages 384--385.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>ndarray</code> <p>The initial state.</p> required <code>dx</code> <code>ndarray</code> <p>The Newton direction.</p> required <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the formation constants.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometric matrix.</p> required <code>T</code> <code>ndarray</code> <p>The total concentration.</p> required <code>lmax</code> <code>ndarray</code> <p>The maximum step allowed.</p> <code>None</code> <code>g0</code> <code>ndarray</code> <p>The value of the function at \u03bb=0.</p> <code>None</code> <code>g2</code> <code>ndarray</code> <p>The value of the function at \u03bb=0.99\u03bb(max).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>lmin</code> <code>ndarray</code> <p>The minimum step.</p> <code>gmin</code> <code>ndarray</code> <p>The value of the function at the minimum step.</p> Source code in <code>src/libeq/solver/nr.py</code> <pre><code>def linesearch3(\n    x0: npt.NDArray,\n    dx: npt.NDArray,\n    log_beta: npt.NDArray,\n    stoichiometry: npt.NDArray,\n    T: npt.NDArray,\n    lmax=None,\n    g0=None,\n    g2=None,\n):\n    r\"\"\"Three-point parabolic line search.\n\n    This functions implements a 3-point linesearch in the Newton direction.\n    This is a variation of the line search for 2 points[^1]. The function to\n    be minimized is the same though but the approach is different and it is\n    adapted to the nature of the problem of concentration solving. We define\n    a function $(f=\\frac12F\\cdot F)$ which is to be minimized. Then we\n    define a parameter $\\lambda$ that $0&lt;\\lambda&lt;1$ which is the fraction of the Newton step\n    and then another function *g* which is function of the fractional is\n    defined so that:\n    $$\n    g(\\lambda) = f(x_0 + \\lambda \\delta x)\n    $$\n    We know that negative $x_0$ values are forbidden, therefore $\\lambda$ might limited\n    to values lower than 1. The maximum value allowed for $\\lambda$ is that that makes\n    any concentration equal to 0, therefore\n    $(\\lambda_{max} = -x_0/\\delta$ if $-x_0/\\delta&lt;1)$\n\n    $g(\\lambda)$ is modeled as a parabolic function for which we calculate\n    the values for $\\lambda=0$, $\\lambda= \\frac{1}{2}\\lambda_{max}$ and $\\lambda=0.99\\lambda_{max}$.\n\n    [^1]: W. H. Press, S. A. Teukolksy, W. T. Vetterling, Brian P. Flannery,\n       Numerical Recipes in C. The Art of Scientific Computing, Second Edition\n       1997, pages 384--385.\n\n    Parameters\n    ----------\n    x0 : np.ndarray\n        The initial state.\n    dx : np.ndarray\n        The Newton direction.\n    log_beta : np.ndarray\n        The logarithm of the formation constants.\n    stoichiometry : np.ndarray\n        The stoichiometric matrix.\n    T : np.ndarray\n        The total concentration.\n    lmax : np.ndarray\n        The maximum step allowed.\n    g0 : np.ndarray\n        The value of the function at \u03bb=0.\n    g2 : np.ndarray\n        The value of the function at \u03bb=0.99\u03bb(max).\n\n    Returns\n    -------\n    lmin : np.ndarray\n        The minimum step.\n    gmin : np.ndarray\n        The value of the function at the minimum step.\n    \"\"\"\n    nerr = np.geterr()\n    np.seterr(all=\"ignore\")\n\n    def g(lambda_):\n        \"Auxiliary function.\"\n        FF = fobj(\n            species_concentration(\n                x0 + lambda_[:, np.newaxis] * dx, log_beta, stoichiometry, full=True\n            ),\n            stoichiometry,\n            T,\n        )\n        return 0.5 * np.sum(np.square(FF), axis=1)\n\n    if lmax is None:\n        lmax = -x0 / dx  # may cause division by 0\n        lmax[lmax &lt; 0.0] = 1.0\n        lmax = np.min(lmax, axis=1)\n\n    if g0 is None:\n        g0 = g(np.zeros_like(lmax))\n\n    g1 = g(lmax / 2)\n    x1 = x0 + lmax[:, None] * dx\n    x1[x1 &lt; 0.0] = 0.0\n    if g2 is None:\n        g2 = g(0.99 * lmax)\n\n    b = -g2 + 4 * g1 - 3 * g0\n    a = (g2 - g0 - b) / lmax\n    lmin = -0.5 * b / a  # may cause division by 0\n\n    # In the unlikely case where a == 0.0 meaning g0 == g1 == g2 we set the\n    # step halfway.\n    w = a == 0.0\n    if np.any(w):\n        lmin[w] = lmax[w] / 2\n\n    w = lmin &lt; 0.1 * lmax  # Set minimum step as 0.1\u03bb(max)\n    lmin[w] = 0.1 * lmax[w]\n\n    w = lmin &gt; lmax  # In the unlikely case where \u03bb(min)&gt;\u03bb(max), set\n    lmin[w] = 0.95 * lmax[w]  # \u03bb(min) close enough to \u03bb(max)\n\n    gmin = g(lmin)\n\n    # Check g(lmin) &lt; g0\n    w2 = gmin &gt; g0\n    if log_beta.ndim == 1:\n        _beta = log_beta\n    else:\n        _beta = log_beta[w2]\n    if np.any(w2):\n        lmin[w2], gmin[w2] = linesearch3(\n            x0[w2],\n            dx[w2],\n            _beta,\n            stoichiometry,\n            T[w2],\n            lmax=lmax[w2] / 2,\n            g0=g0[w2],\n            g2=gmin[w2],\n        )\n    np.seterr(**nerr)\n    return lmin, gmin\n</code></pre>"},{"location":"reference/libeq/solver/nr/#libeq.solver.nr.limit_step","title":"limit_step","text":"<pre><code>limit_step(x, dx)\n</code></pre> <p>Limit step.</p> <p>Given a state (x) and a step (dx), the next state is expected to be (x+dx). However, in some cases negative values are forbidden. This may happen for small values of the state. In the case of x being small we can approximate (\\(x+1 \\approx e^{-x}\\))</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>The state. It must be 1D.</p> required <code>dx</code> <code>ndarray</code> <p>The step. It must have the same length as x.</p> required <p>Returns:</p> Name Type Description <code>new_dx</code> <code>ndarray</code> <p>The limited step.</p> Source code in <code>src/libeq/solver/nr.py</code> <pre><code>def limit_step(x, dx):\n    r\"\"\"\n    Limit step.\n\n    Given a state (x) and a step (dx), the next state is expected to be\n    (x+dx). However, in some cases negative values are forbidden. This\n    may happen for small values of the state. In the case of x being small\n    we can approximate ($x+1 \\approx e^{-x}$)\n\n    Parameters\n    ----------\n    x : numpy.ndarray\n        The state. It must be 1D.\n    dx : numpy.ndarray\n        The step. It must have the same length as x.\n\n    Returns\n    -------\n    new_dx : numpy.ndarray\n        The limited step.\n    \"\"\"\n    if len(x) != len(dx):\n        raise ValueError(\"both arguments must have the same size\")\n    # return np.where(who, x+dx, x*np.exp(dx))\n    one_over_del = (-dx * x) / (0.5 * x)\n    rev_del = 1 / np.where(one_over_del &gt; 1, one_over_del, 1)\n\n    return dx * rev_del\n</code></pre>"},{"location":"reference/libeq/solver/nr/#libeq.solver.nr.DRScaling","title":"DRScaling","text":"<pre><code>DRScaling(J, F)\n</code></pre> <p>Apply scaling to both jacobian and objective function.</p> <p>Applies scaling technique according to De Robertis, et al. <sup>1</sup> The scaling technique overcomes the problem of divergence when the jacobian (here called G) matrix is near singular. \"... scaling was applied to matrix G and to vector e (residuals, \\(e = C_{k, calcd} - C_k\\) according to the equations \\(g_{kj}^* = g_{kj}(g_{kk}g_{jj})^{-1/2}\\) and \\((e_k^* = e_kg_{kk}^{-1/2}\\) where \\(g_{kj}^*)\\) and \\((e_k^*)\\) are the elements of the scaled matrix and vector respectively.\"</p> \\[ J^*_{kj} = J_{kj}(J_{kk}J_{jj})^{-1/2}\\\\ F^*_{k} = F_{k}J_{kk}^{-1/2} \\] <ol> <li> <p>De Robertis, et al.: Analytica Chimica Acta 1986, 191, 385-398\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>J</code> <code>ndarray</code> <p>jacobian array, which will be modified. It can be of any dimensionality provided that the last two are of the same size.</p> required <code>F</code> <code>ndarray</code> <p>residuals array, which will be modified. If must have one dimmension less than J and the rest of the axes be of the same size than J.</p> required <p>Returns:</p> Name Type Description <code>d</code> <code>ndarray</code> <p>The diagonal of the jacobian, \\((J_{ii})\\) to scale back the result.</p> Source code in <code>src/libeq/solver/nr.py</code> <pre><code>def DRScaling(J, F):\n    r\"\"\"Apply scaling to both jacobian and objective function.\n\n    Applies scaling technique according to De Robertis, *et al.* [^1]\n    The scaling technique overcomes the problem of divergence\n    when the jacobian (here called G) matrix is near singular.\n    \"... scaling was applied to matrix *G* and to vector *e*\n    (residuals, $e = C_{k, calcd} - C_k$\n    according to the equations $g_{kj}^* = g_{kj}(g_{kk}g_{jj})^{-1/2}$\n    and $(e_k^* = e_kg_{kk}^{-1/2}$ where $g_{kj}^*)$\n    and $(e_k^*)$ are the elements of the scaled matrix and vector\n    respectively.\"\n\n    $$\n    J^*_{kj} = J_{kj}(J_{kk}J_{jj})^{-1/2}\\\\\n    F^*_{k} = F_{k}J_{kk}^{-1/2}\n    $$\n\n    [^1]: De Robertis, *et al.*: *Analytica Chimica Acta* 1986, **191**, 385-398\n\n\n    Parameters\n    ----------\n    J : numpy.ndarray\n        jacobian array, which will be modified.\n        It can be of any dimensionality provided that the last two are\n        of the same size.\n    F : numpy.ndarray\n        residuals array, which will be modified.\n        If must have one dimmension less than J and the rest of the\n        axes be of the same size than J.\n\n    Returns\n    -------\n    d : numpy.ndarray\n        The diagonal of the jacobian, $(J_{ii})$\n        to scale back the result.\n    \"\"\"\n    d = J[np.arange(J.shape[0])[:, None], np.eye(J.shape[1], dtype=bool)]\n    J /= np.sqrt(d[..., np.newaxis] * d[..., np.newaxis, :])\n    F /= np.sqrt(d)\n    return d\n</code></pre>"},{"location":"reference/libeq/solver/nr/#libeq.solver.nr.fobj","title":"fobj","text":"<pre><code>fobj(\n    concentration,\n    log_ks,\n    stoichiometry,\n    solid_stoichiometry,\n    total_concentration,\n)\n</code></pre> <p>Calculate the objective function for a given set of parameters.</p> <p>Parameters:</p> Name Type Description Default <code>concentration</code> <code>ndarray</code> <p>The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.</p> required <code>log_ks</code> <code>ndarray</code> <p>The logarithm of the solubility products with shape (n, p), where p is the number of solid species.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, s), where s is the number of soluble species.</p> required <code>solid_stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix for solid species with shape (n, p), where p is the number of solid species.</p> required <code>total_concentration</code> <code>ndarray</code> <p>The total concentration vector with shape (n,c), where n is the number of points and c is the number of components.</p> required <p>Returns:</p> Name Type Description <code>delta</code> <code>ndarray</code> <p>The objective function values with shape (n, nt), where nt is the total number of components (n + f).</p> Source code in <code>src/libeq/solver/nr.py</code> <pre><code>def fobj(\n    concentration,\n    log_ks,\n    stoichiometry,\n    solid_stoichiometry,\n    total_concentration,\n):\n    \"\"\"\n    Calculate the objective function for a given set of parameters.\n\n    Parameters\n    ----------\n    concentration : numpy.ndarray\n        The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.\n    log_ks : numpy.ndarray\n        The logarithm of the solubility products with shape (n, p), where p is the number of solid species.\n    stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, s), where s is the number of soluble species.\n    solid_stoichiometry : numpy.ndarray\n        The stoichiometry matrix for solid species with shape (n, p), where p is the number of solid species.\n    total_concentration : numpy.ndarray\n        The total concentration vector with shape (n,c), where n is the number of points and c is the number of components.\n\n    Returns\n    -------\n    delta : numpy.ndarray\n        The objective function values with shape (n, nt), where nt is the total number of components (n + f).\n    \"\"\"\n    nc = stoichiometry.shape[0]\n    nf = concentration.shape[1] - nc - stoichiometry.shape[1]\n\n    c_components = concentration[:, :nc]\n    c_solids = concentration[:, nc : nc + nf]\n    c_species = concentration[:, nc + nf :]\n\n    components_in_species = c_species[:, np.newaxis, :] * stoichiometry[np.newaxis]\n    components_in_species = np.sum(components_in_species, axis=2)\n\n    if c_solids.size &gt; 0:\n        components_in_solids = (\n            c_solids[:, np.newaxis, :] * solid_stoichiometry[np.newaxis]\n        )\n        components_in_solids = np.sum(components_in_solids, axis=2)\n    else:\n        components_in_solids = 0\n\n    delta = (\n        c_components\n        + components_in_species\n        + components_in_solids\n        - total_concentration\n    )\n    if nf &gt; 0:\n        solid_delta = np.log10(c_components) @ solid_stoichiometry - log_ks\n    else:\n        solid_delta = np.empty((delta.shape[0], 0))\n\n    delta = np.concatenate((delta, solid_delta), axis=1)\n\n    return delta\n</code></pre>"},{"location":"reference/libeq/solver/nr/#libeq.solver.nr.jacobian","title":"jacobian","text":"<pre><code>jacobian(concentration, stoichiometry, solid_stoichiometry)\n</code></pre> <p>Compute the Jacobian matrix for the given system of equations.</p> <p>Parameters:</p> Name Type Description Default <code>concentration</code> <code>ndarray</code> <p>The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix of shape (c, s), representing the stoichiometric coefficients of the soluble components.</p> required <code>solid_stoichiometry</code> <code>ndarray</code> <p>The solid stoichiometry matrix of shape (n, p), representing the stoichiometric coefficients of the solid components.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>The Jacobian matrix of shape (n, nt, nt), where nt is the total number of components (n + f).</p> Source code in <code>src/libeq/solver/nr.py</code> <pre><code>def jacobian(concentration, stoichiometry, solid_stoichiometry):\n    \"\"\"\n    Compute the Jacobian matrix for the given system of equations.\n\n    Parameters\n    ----------\n    concentration : numpy.ndarray\n        The concentration array of shape (n, c+p), where n is the number of points c is the number of components and p is the number of solid species.\n    stoichiometry : numpy.ndarray\n        The stoichiometry matrix of shape (c, s), representing the stoichiometric coefficients of the soluble components.\n    solid_stoichiometry : numpy.ndarray\n        The solid stoichiometry matrix of shape (n, p), representing the stoichiometric coefficients of the solid components.\n\n    Returns\n    -------\n    numpy.ndarray\n        The Jacobian matrix of shape (n, nt, nt), where nt is the total number of components (n + f).\n\n    \"\"\"\n    nt = nc = stoichiometry.shape[0]\n    nf = solid_stoichiometry.shape[1]\n    nt += nf\n\n    J = np.zeros(shape=(concentration.shape[0], nt, nt))\n    diagonals = np.einsum(\n        \"ij,jk-&gt;ijk\", concentration[:, nt:], np.eye(concentration.shape[1] - nt)\n    )\n    # Compute Jacobian for soluble components only\n    J[:, :nc, :nc] = stoichiometry @ diagonals @ stoichiometry.T\n    J[:, range(nc), range(nc)] += concentration[:, :nc]\n\n    # Add solid contribution if necessary\n    if nf &gt; 0:\n        J[:, nc:nt, :nc] = solid_stoichiometry.T\n        J[:, :nc, nc:nt] = solid_stoichiometry\n    return J\n</code></pre>"},{"location":"reference/libeq/solver/solids_solver/","title":"solids_solver","text":""},{"location":"reference/libeq/solver/solids_solver/#libeq.solver.solids_solver.solids_solver","title":"solids_solver","text":"<pre><code>solids_solver(\n    concentrations: NDArray,\n    log_beta,\n    log_ks,\n    original_log_beta,\n    original_log_ks,\n    stoichiometry,\n    solid_stoichiometry,\n    total_concentration,\n    outer_fiexd_point_params,\n)\n</code></pre> <p>Solve for concentrations of solids in a chemical equilibrium system.</p> <p>Parameters:</p> Name Type Description Default <code>concentrations</code> <code>ndarray</code> <p>The concentration array of shape (n, c), where n is the number of points c is the number of components.</p> required <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the equilibrium constants with shape (n, s), where s is the number of soluble species.</p> required <code>log_ks</code> <code>ndarray</code> <p>The logarithm of the solubility products with shape (n, p), where p is the number of solid species.</p> required <code>original_log_beta</code> <code>ndarray</code> <p>The logarithm of the equilibrium constants at reference ionic strength with shape (n, s), where s is the number of soluble species.</p> required <code>original_log_ks</code> <code>ndarray</code> <p>The logarithm of the solubility products at reference ionic strength with shape (n, p), where p is the number of solid species.</p> required <code>stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, s), where s is the number of soluble species.</p> required <code>solid_stoichiometry</code> <code>ndarray</code> <p>The stoichiometry matrix with shape (n, p), where s is the number of precipitable species.</p> required <code>total_concentration</code> <code>ndarray</code> <p>The total concentration vector with shape (n, c), where n is the number of points c is the number of components..</p> required <code>outer_fiexd_point_params</code> <code>dict</code> <p>Dict of parameters for the outer fixed point function.</p> required <p>Returns:</p> Name Type Description <code>final_result</code> <code>ndarray</code> <p>Array of final concentrations of all components in the system.</p> <code>final_log_beta</code> <code>ndarray</code> <p>Array of final logarithm of the formation constants for all components in the system.</p> <code>final_log_ks</code> <code>ndarray</code> <p>Array of final logarithm of the solubility product constants for all solid components in the system.</p> <code>final_saturation_index</code> <code>ndarray</code> <p>Array of final saturation indices for all solid components in the system.</p> Source code in <code>src/libeq/solver/solids_solver.py</code> <pre><code>def solids_solver(\n    concentrations: NDArray,\n    log_beta,\n    log_ks,\n    original_log_beta,\n    original_log_ks,\n    stoichiometry,\n    solid_stoichiometry,\n    total_concentration,\n    outer_fiexd_point_params,\n):\n    \"\"\"\n    Solve for concentrations of solids in a chemical equilibrium system.\n\n    Parameters\n    ----------\n    concentrations : numpy.ndarray\n        The concentration array of shape (n, c), where n is the number of points c is the number of components.\n    log_beta : numpy.ndarray\n        The logarithm of the equilibrium constants with shape (n, s), where s is the number of soluble species.\n    log_ks : numpy.ndarray\n        The logarithm of the solubility products with shape (n, p), where p is the number of solid species.\n    original_log_beta : numpy.ndarray\n        The logarithm of the equilibrium constants at reference ionic strength with shape (n, s), where s is the number of soluble species.\n    original_log_ks : numpy.ndarray\n        The logarithm of the solubility products at reference ionic strength with shape (n, p), where p is the number of solid species.\n    stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, s), where s is the number of soluble species.\n    solid_stoichiometry : numpy.ndarray\n        The stoichiometry matrix with shape (n, p), where s is the number of precipitable species.\n    total_concentration : numpy.ndarray\n        The total concentration vector with shape (n, c), where n is the number of points c is the number of components..\n    outer_fiexd_point_params : dict\n        Dict of parameters for the outer fixed point function.\n\n    Returns\n    -------\n    final_result : numpy.ndarray\n        Array of final concentrations of all components in the system.\n    final_log_beta : numpy.ndarray\n        Array of final logarithm of the formation constants for all components in the system.\n    final_log_ks : numpy.ndarray\n        Array of final logarithm of the solubility product constants for all solid components in the system.\n    final_saturation_index : numpy.ndarray\n        Array of final saturation indices for all solid components in the system.\n    \"\"\"\n    final_result = np.empty_like(concentrations)\n    final_log_beta = np.empty_like(log_beta)\n    final_log_ks = np.empty_like(log_ks)\n    final_saturation_index = np.empty_like(log_ks)\n\n    all_saturation_index = _compute_saturation_index(\n        concentrations[:, : solid_stoichiometry.shape[0]], log_ks, solid_stoichiometry\n    )\n\n    all_indices = set(range(concentrations.shape[0]))\n    no_solids_points = np.where((all_saturation_index &lt; 1).all(axis=1))[0].tolist()\n\n    final_result[no_solids_points] = concentrations[no_solids_points]\n    final_log_beta[no_solids_points] = log_beta[no_solids_points]\n    final_log_ks[no_solids_points] = log_ks[no_solids_points]\n\n    solids_points = all_indices - set(no_solids_points)\n\n    independent_component_activity = outer_fiexd_point_params.pop(\n        \"independent_component_activity\", None\n    )\n\n    for point in solids_points:\n        solids_set = set()\n        (\n            c,\n            point_log_ks,\n            saturation_index,\n            point_total_concentration,\n            point_independent_component_activity,\n        ) = _get_point_values(\n            concentrations,\n            log_ks,\n            all_saturation_index,\n            total_concentration,\n            independent_component_activity,\n            point,\n        )\n\n        adjust_solids = True\n        newton_raphson_solver = outer_fixed_point(\n            **outer_fiexd_point_params,\n            independent_component_activity=point_independent_component_activity,\n        )(newton_raphson)\n\n        while adjust_solids:\n            solids_set, adjust_solids = _update_solids_set(\n                total_concentration, c, point_log_ks, saturation_index, solids_set\n            )\n\n            if not adjust_solids:\n                break\n\n            c, point_log_beta, point_log_ks = newton_raphson_solver(\n                c,\n                log_beta=original_log_beta[point],\n                log_ks=original_log_ks[point],\n                stoichiometry=stoichiometry,\n                solid_stoichiometry=solid_stoichiometry,\n                solids_idx=list(solids_set),\n                total_concentration=point_total_concentration,\n                max_iterations=1000,\n                threshold=1e-10,\n            )\n            saturation_index = _compute_saturation_index(\n                c[:, : solid_stoichiometry.shape[0]], point_log_ks, solid_stoichiometry\n            )\n\n        final_result[point] = c\n        final_log_beta[point] = point_log_beta\n        final_log_ks[point] = point_log_ks\n        final_saturation_index[point] = saturation_index\n\n    return final_result, final_log_beta, final_log_ks, final_saturation_index\n</code></pre>"},{"location":"reference/libeq/solver/solver/","title":"solver","text":""},{"location":"reference/libeq/solver/solver/#libeq.solver.solver.EqSolver","title":"EqSolver","text":"<pre><code>EqSolver(\n    data: SolverData,\n    mode: Literal[\n        \"titration\", \"distribution\"\n    ] = \"titration\",\n)\n</code></pre> <p>Solve the equilibrium equations for a given chemical system.</p> <p>The solver uses a conjuntion of methods to solve the problem at hand. In particular:</p> <ul> <li>The Positive Continious Fraction Method (PCFM) is used to presolve the equilibrium equations.</li> <li>The Newton-Raphson method is used to solve the equilibrium equations.</li> <li>The outer fixed point method is used to solve the equilibrium equations for solids.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>SolverData</code> <p>The input data containing all the necessary information for the solver.</p> required <code>mode</code> <code>(titration, distribution)</code> <p>The mode of operation for the solver. Default is \"titration\".</p> <code>\"titration\"</code> <p>Returns:</p> Name Type Description <code>result</code> <code>ndarray</code> <p>The calculated equilibrium concentrations.</p> <code>log_beta</code> <code>ndarray</code> <p>The logarithm of the stability constants.</p> <code>log_ks</code> <code>ndarray</code> <p>The logarithm of the solubility products.</p> <code>saturation_index</code> <code>ndarray</code> <p>The calculated saturation indices for solid phases.</p> <code>total_concentration</code> <code>ndarray</code> <p>The total concentrations used in the calculations.</p> Source code in <code>src/libeq/solver/solver.py</code> <pre><code>def EqSolver(\n    data: SolverData, mode: Literal[\"titration\", \"distribution\"] = \"titration\"\n):\n    \"\"\"\n    Solve the equilibrium equations for a given chemical system.\n\n    The solver uses a conjuntion of methods to solve the problem at hand. In particular:\n\n    - The Positive Continious Fraction Method (PCFM) is used to presolve the equilibrium equations.\n    - The Newton-Raphson method is used to solve the equilibrium equations.\n    - The outer fixed point method is used to solve the equilibrium equations for solids.\n\n    Parameters\n    ----------\n    data : SolverData\n        The input data containing all the necessary information for the solver.\n    mode : {\"titration\", \"distribution\"}, optional\n        The mode of operation for the solver. Default is \"titration\".\n\n    Returns\n    -------\n    result : ndarray\n        The calculated equilibrium concentrations.\n    log_beta : ndarray\n        The logarithm of the stability constants.\n    log_ks : ndarray\n        The logarithm of the solubility products.\n    saturation_index : ndarray\n        The calculated saturation indices for solid phases.\n    total_concentration : ndarray\n        The total concentrations used in the calculations.\n    \"\"\"\n    # Get the total concentration values depending if mode is titration or distribution\n    if mode == \"titration\":\n        (\n            stoichiometry,\n            solid_stoichiometry,\n            original_log_beta,\n            original_log_ks,\n            charges,\n            independent_component_activity,\n            total_concentration,\n        ) = _prepare_titration_data(data)\n    elif mode == \"distribution\":\n        (\n            stoichiometry,\n            solid_stoichiometry,\n            original_log_beta,\n            original_log_ks,\n            charges,\n            independent_component_activity,\n            total_concentration,\n            independent_component,\n            independent_component_concentration,\n        ) = _prepare_distribution_data(data)\n    else:\n        raise ValueError(\"Invalid work mode\")\n\n    outer_fiexd_point_params = _assemble_outer_fixed_point_params(\n        data, charges, independent_component_activity\n    )\n\n    # Solve the equilibrium equations\n    result, log_beta, log_ks, saturation_index, total_concentration = (\n        solve_equilibrium_equations(\n            stoichiometry=stoichiometry,\n            solid_stoichiometry=solid_stoichiometry,\n            original_log_beta=original_log_beta,\n            original_log_ks=original_log_ks,\n            total_concentration=total_concentration,\n            outer_fiexd_point_params=outer_fiexd_point_params,\n        )\n    )\n\n    if mode == \"distribution\":\n        result, log_beta, log_ks, total_concentration = _expand_result(\n            result,\n            independent_component,\n            independent_component_concentration,\n            total_concentration,\n            log_beta,\n            log_ks,\n            data.stoichiometry,\n            data.solid_stoichiometry,\n        )\n    return result, log_beta, log_ks, saturation_index, total_concentration\n</code></pre>"},{"location":"reference/libeq/solver/solver/#libeq.solver.solver.solve_equilibrium_equations","title":"solve_equilibrium_equations","text":"<pre><code>solve_equilibrium_equations(\n    *,\n    stoichiometry,\n    solid_stoichiometry,\n    original_log_beta,\n    original_log_ks,\n    total_concentration,\n    outer_fiexd_point_params,\n    initial_guess=None,\n    full=False\n)\n</code></pre> Source code in <code>src/libeq/solver/solver.py</code> <pre><code>def solve_equilibrium_equations(\n    *,\n    stoichiometry,\n    solid_stoichiometry,\n    original_log_beta,\n    original_log_ks,\n    total_concentration,\n    outer_fiexd_point_params,\n    initial_guess=None,\n    full=False,\n):\n    if initial_guess is None:\n        initial_guess = np.full_like(total_concentration, 1e-10)\n    else:\n        initial_guess = np.atleast_2d(initial_guess)\n\n    damping_fn = outer_fixed_point(\n        **outer_fiexd_point_params,\n    )(pcf)\n\n    nr_fn = outer_fixed_point(\n        **outer_fiexd_point_params,\n    )(newton_raphson)\n\n    # Get the initial guess for the free concentrations\n    damped_guess, log_beta, log_ks = damping_fn(\n        initial_guess,\n        log_beta=original_log_beta,\n        log_ks=original_log_ks,\n        stoichiometry=stoichiometry,\n        solid_stoichiometry=solid_stoichiometry,\n        total_concentration=total_concentration,\n        tol=1e-3,\n    )\n\n    # Add the solid concentrations to the initial guess\n    damped_guess = np.concatenate(\n        (\n            damped_guess,\n            np.full((damped_guess.shape[0], solid_stoichiometry.shape[1]), 0),\n        ),\n        axis=1,\n    )\n\n    # Apply Newton-Raphson iterations\n    result, log_beta, log_ks = nr_fn(\n        damped_guess,\n        log_beta=original_log_beta,\n        log_ks=original_log_ks,\n        stoichiometry=stoichiometry,\n        solid_stoichiometry=solid_stoichiometry,\n        total_concentration=total_concentration,\n        max_iterations=1000,\n        threshold=1e-10,\n    )\n\n    if solid_stoichiometry.shape[1] &gt; 0:\n        result, log_beta, log_ks, saturation_index = solids_solver(\n            result,\n            log_beta,\n            log_ks,\n            original_log_beta,\n            original_log_ks,\n            stoichiometry,\n            solid_stoichiometry,\n            total_concentration,\n            outer_fiexd_point_params=outer_fiexd_point_params,\n        )\n    else:\n        saturation_index = np.empty((result.shape[0], 0))\n\n    if full:\n        result = species_concentration(result, log_beta, stoichiometry, full)\n\n    return result, log_beta, log_ks, saturation_index, total_concentration\n</code></pre>"},{"location":"reference/libeq/solver/solver_utils/","title":"solver_utils","text":""},{"location":"tutorials/","title":"Tutorials","text":"<p>In this section you can find a series of tutorials on how to practically use <code>libeq</code> for solving some common thermodynamic problems.</p> <ol> <li> <p>Species Distributions</p> <ul> <li>Species Distribution (fixed ionic strength)</li> <li>Species Distribution (variable ionic strength)</li> <li>Species Distribution (with solids forming)</li> </ul> </li> <li> <p>Titration Simulations</p> <ul> <li>Titration Simulation (fixed ionic strength)</li> <li>Titration Simulation (variable ionic strength)</li> </ul> </li> </ol>"},{"location":"tutorials/legacy_import/","title":"Legacy Import","text":"<p><code>libeq</code> has some utilities to load the data needed for its calculation from various legacy software for the study of thermodynamic equilibrium, notably HYPERQUAD and BSTAC.</p>"}]}